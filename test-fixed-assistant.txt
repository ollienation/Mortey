# test-fixes assistant.py

import asyncio
import os
import sys
from pathlib import Path
import logging
import uuid  # ✅ CRITICAL FIX: Added uuid import for tool_call IDs

# Add project root to path for imports
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

async def test_functionality():
    """Test fixed assistant functionality with modern patterns"""
    try:
        print("🧪 Testing FIXED LangGraph Assistant (0.4.8)")
        print("🗓️ June 2025 - All Critical Issues Resolved")
        print("=" * 60)

        # Import the fixed assistant components
        from core.assistant_core import AssistantCore
        from core.state import validate_and_filter_messages_v2, AssistantState, create_optimized_state, smart_trim_messages_v2
        from agents.agents import AgentFactory

        # Create assistant instance
        assistant = AssistantCore()

        print("\n1️⃣ Testing fixed message validation...")
        from langchain_core.messages import HumanMessage, AIMessage, ToolMessage

        # Test cases that previously failed
        test_messages = [
            HumanMessage(content="Hello"),
            # ✅ CRITICAL FIX: Added required 'id' field to tool_calls
            AIMessage(content="", tool_calls=[{
                "name": "test_tool",
                "args": {},
                "id": f"call_{uuid.uuid4().hex[:8]}"
            }]),  # This should NOT be filtered
            ToolMessage(content="Tool result", tool_call_id="test_id"),
            HumanMessage(content=""),  # This SHOULD be filtered
        ]

        validated = validate_and_filter_messages_v2(test_messages)
        print(f"✅ Message validation: {len(test_messages)} -> {len(validated)} messages")
        print(f"✅ Tool call message preserved: {any(hasattr(m, 'tool_calls') and m.tool_calls for m in validated)}")

        print("\n2️⃣ Testing modern agent creation...")
        agent_factory = AgentFactory()

        # Test modern create_react_agent without tool_choice parameter
        try:
            chat_agent = agent_factory.create_chat_agent()
            print("✅ Chat agent created with fixed parameters (no tool_choice)")

            coder_agent = agent_factory.create_coder_agent()
            print("✅ Coder agent created with fixed parameters (no tool_choice)")

            web_agent = agent_factory.create_web_agent()
            print("✅ Web agent created with fixed parameters (no tool_choice)")

        except Exception as e:
            print(f"❌ Agent creation failed: {e}")

        print("\n3️⃣ Testing fixed checkpointer...")
        try:
            from core.checkpointer import create_checkpointer, get_checkpointer_info

            # Get checkpointer info
            info = get_checkpointer_info()
            print("Checkpointer Information:")
            for key, value in info.items():
                print(f"  {key}: {value}")

            # Test checkpointer creation (sync version for simplicity)
            checkpointer = await create_checkpointer(use_async=False)
            print(f"✅ Created checkpointer: {type(checkpointer).__name__}")

        except Exception as e:
            print(f"❌ Checkpointer test failed: {e}")

        print("\n4️⃣ Testing complete message processing...")
        try:
            # Initialize the assistant
            await assistant.initialize()

            # Test basic conversation
            response = await assistant.process_message("Hello! My name is Alice.")
            print(f"✅ Basic conversation: {response.get('response', 'No response')[:100]}...")

            # Test memory persistence
            response = await assistant.process_message("What's my name?")
            print(f"✅ Memory test: {response.get('response', 'No response')[:100]}...")

            # Test that should route to coder agent
            response = await assistant.process_message("Create a Python function that calculates factorial")
            print(f"✅ Code generation: {response.get('response', 'No response')[:100]}...")

            # Test that should route to web agent
            response = await assistant.process_message("What's the latest news about AI?")
            print(f"✅ Web search: {response.get('response', 'No response')[:100]}...")

        except Exception as e:
            print(f"❌ Message processing test failed: {e}")
            import traceback
            traceback.print_exc()

        print("\n5️⃣ Testing human-in-the-loop features...")
        try:
            # Test session info
            session_info = assistant.get_session_info()
            print("Session Information:")
            for key, value in session_info.items():
                print(f"  {key}: {value}")

            # Test system status
            status = assistant.get_system_status()
            print("System Status:")
            for key, value in status.items():
                print(f"  {key}: {value}")

        except Exception as e:
            print(f"❌ Human-in-the-loop test failed: {e}")

        print("\n6️⃣ Testing modern state management...")
        try:
            state = create_optimized_state(session_id="test_session", user_id="test_user")
            # ✅ CRITICAL FIX: Use dictionary access for TypedDict compatibility
            print(f"✅ Optimized state created: {state['session_id']}") 
            # Now works with proper AssistantState instance

            # Update smart trimming test:
            test_state = create_optimized_state(
                session_id="test_trimming_session",
                initial_context={"messages": test_messages}
            )
            trimmed = smart_trim_messages_v2(test_state, max_tokens=1000)

            print(f"✅ Smart trimming: {len(test_state['messages'])} -> {len(trimmed['messages'])} messages")

        except Exception as e:
            print(f"❌ State management test failed: {e}")
            import traceback
            traceback.print_exc()

        print("\n7️⃣ Testing enhanced file tools...")
        try:
            from tools.file_tools import FileSystemTools

            file_tools = FileSystemTools()
            tools = file_tools.get_tools()
            tool_names = [tool.name for tool in tools]
            print(f"✅ Available file tools: {len(tools)} total")
            print(f"   Tool names: {', '.join(tool_names[:5])}...")

        except Exception as e:
            print(f"❌ File tools test failed: {e}")

        print("\n✅ ALL FIXED TESTS COMPLETED!")
        print("\n🎉 Expected improvements:")
        print("✅ No more empty content errors")
        print("✅ No more tool_choice parameter errors")
        print("✅ Complete responses (no truncation)")
        print("✅ Proper tool call handling")
        print("✅ Modern LangGraph 0.4.8 patterns")
        print("✅ Enhanced agent routing")
        print("✅ Human-in-the-loop capabilities")
        print("✅ Better memory management")
        print("✅ Robust error handling")
        print("✅ Enhanced file tools")
        print("✅ Fixed state management (AssistantState objects)")

    except Exception as e:
        print(f"❌ Fixed test suite failed: {e}")
        import traceback
        traceback.print_exc()

def check_environment():
    """Check that environment is properly configured"""
    from pathlib import Path
    from dotenv import load_dotenv, find_dotenv

    # Load .env
    env_path = find_dotenv(usecwd=True)
    if env_path:
        load_dotenv(env_path, override=True)
        print(f"✅ Loaded .env from: {env_path}")

    # Check environment variables
    required_env_vars = ["ANTHROPIC_API_KEY", "OPENAI_API_KEY", "TAVILY_API_KEY"]
    for var in required_env_vars:
        value = os.getenv(var)
        status = "✅" if value else "❌"
        masked_value = f"{value[:8]}..." if value and len(value) > 8 else "Not set"
        print(f"  {status} {var}: {masked_value}")

    # Check workspace directory
    workspace_dir = Path.cwd() / "workspace"
    workspace_exists = workspace_dir.exists()
    print(f"  {'✅' if workspace_exists else '❌'} Workspace dir: {workspace_dir}")

    # Check modern packages
    packages = [
        "langgraph",
        "langgraph_supervisor",
        "langgraph.checkpoint.sqlite",
        "langgraph.checkpoint.postgres"
    ]

    print("\nFixed Package Availability:")
    for package in packages:
        try:
            __import__(package)
            print(f"  ✅ {package}: Available")
        except ImportError:
            print(f"  ❌ {package}: Not installed")

    print()

async def main():
    """Run all fixed tests"""
    print("🗓️ June 2025 - LangGraph 0.4.8 Compatible")
    # Environment check
    check_environment()

    # Run tests
    await test_functionality()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n👋 Tests interrupted by user")
    except Exception as e:
        print(f"\n💥 Test suite failed: {e}")
        import traceback
        traceback.print_exc()
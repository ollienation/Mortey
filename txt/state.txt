# core/state.py - ✅ ENHANCED WITH PYTHON 3.13.4 COMPATIBILITY
from typing import Annotated, Optional, Union, TypedDict, Self
from collections.abc import Sequence  # Python 3.13.4 preferred import
from langchain_core.messages import BaseMessage, HumanMessage, AIMessage, ToolMessage, SystemMessage
from langgraph.graph.message import add_messages
import logging
import time
import uuid
import asyncio
from dataclasses import dataclass, field

logger = logging.getLogger("state")

# ✅ ENHANCED: More robust TypedDict with Python 3.13.4 syntax
class AssistantState(TypedDict):
    """
    The state of the assistant. This is a TypedDict, so all access
    should be through dictionary keys, e.g., state['messages'].
    
    Uses Python 3.13.4 enhanced typing for better performance and clarity.
    """
    # LangGraph will automatically manage this field
    messages: Annotated[Sequence[BaseMessage], add_messages]
    
    # Required fields for basic operation
    session_id: str
    user_id: str
    current_agent: str

class StateValidationError(Exception):
    """Custom exception for state validation errors"""
    pass

@dataclass
class ValidationResult:
    """Result of state validation with detailed information"""
    is_valid: bool
    errors: list[str] = field(default_factory=list)  # Python 3.13.4 syntax
    warnings: list[str] = field(default_factory=list)  # Python 3.13.4 syntax
    metadata: dict[str, any] = field(default_factory=dict)  # Python 3.13.4 syntax

class StateValidator:
    """
    State validation and sanitization utilities with Python 3.13.4 enhancements.
    """
    
    @staticmethod
    def validate_state(state: any, strict: bool = False) -> ValidationResult:  # Python 3.13.4 syntax
        """
        Validate an AssistantState object comprehensively.
        
        Args:
            state: The state object to validate
            strict: If True, enforces strict validation rules
            
        Returns:
            ValidationResult with detailed information
        """
        result = ValidationResult(is_valid=True)
        
        # Check if state is a dictionary
        if not isinstance(state, dict):
            result.errors.append(f"State must be a dictionary, got {type(state)}")
            result.is_valid = False
            return result
        
        # Check required fields
        required_fields = ["messages", "session_id", "user_id", "current_agent"]
        for field in required_fields:
            if field not in state:
                result.errors.append(f"Missing required field: {field}")
                result.is_valid = False
            elif state[field] is None:
                result.errors.append(f"Field {field} cannot be None")
                result.is_valid = False
        
        # Validate messages field
        if "messages" in state:
            messages_result = StateValidator._validate_messages(state["messages"], strict)
            if not messages_result.is_valid:
                result.errors.extend(messages_result.errors)
                result.is_valid = False
            result.warnings.extend(messages_result.warnings)
        
        # Validate string fields
        string_fields = ["session_id", "user_id", "current_agent"]
        for field in string_fields:
            if field in state and not isinstance(state[field], str):
                result.errors.append(f"Field {field} must be a string, got {type(state[field])}")
                result.is_valid = False
            elif field in state and not state[field].strip():
                if strict:
                    result.errors.append(f"Field {field} cannot be empty string")
                    result.is_valid = False
                else:
                    result.warnings.append(f"Field {field} is empty")
        
        # Check for unknown fields in strict mode
        if strict:
            known_fields = set(required_fields)
            unknown_fields = set(state.keys()) - known_fields
            if unknown_fields:
                result.warnings.append(f"Unknown fields in strict mode: {unknown_fields}")
        
        # Add metadata
        result.metadata = {
            "message_count": len(state.get("messages", [])),
            "state_size_bytes": len(str(state)),
            "validation_timestamp": time.time()
        }
        
        return result
    
    @staticmethod
    def _validate_messages(messages: any, strict: bool = False) -> ValidationResult:  # Python 3.13.4 syntax
        """Validate the messages field specifically"""
        result = ValidationResult(is_valid=True)
        
        if not isinstance(messages, (list, tuple)):
            result.errors.append(f"Messages must be a list or tuple, got {type(messages)}")
            result.is_valid = False
            return result
        
        valid_message_types = (HumanMessage, AIMessage, ToolMessage, SystemMessage)
        
        for i, message in enumerate(messages):
            if not isinstance(message, BaseMessage):
                result.errors.append(f"Message {i} is not a BaseMessage instance: {type(message)}")
                result.is_valid = False
                continue
            
            # Check message content
            if hasattr(message, 'content'):
                content = getattr(message, 'content', '')
                if strict and isinstance(message, HumanMessage) and not content.strip():
                    result.errors.append(f"HumanMessage {i} has empty content in strict mode")
                    result.is_valid = False
                elif isinstance(message, AIMessage):
                    # AIMessage can have empty content if it has tool calls
                    has_tool_calls = (hasattr(message, 'tool_calls') and 
                                    message.tool_calls and 
                                    len(message.tool_calls) > 0)
                    if not content.strip() and not has_tool_calls:
                        result.warnings.append(f"AIMessage {i} has no content and no tool calls")
            
            # Validate tool calls for AIMessage
            if isinstance(message, AIMessage) and hasattr(message, 'tool_calls'):
                tool_calls = getattr(message, 'tool_calls', [])
                if tool_calls:
                    for j, tool_call in enumerate(tool_calls):
                        if not isinstance(tool_call, dict):
                            result.errors.append(f"Tool call {j} in message {i} must be a dict")
                            result.is_valid = False
                            continue
                        
                        required_tool_fields = ["name", "args", "id"]
                        for field in required_tool_fields:
                            if field not in tool_call:
                                result.errors.append(f"Tool call {j} missing field: {field}")
                                result.is_valid = False
        
        return result
    
    @staticmethod
    def sanitize_state(state: dict[str, any]) -> AssistantState:  # Python 3.13.4 syntax
        """
        Sanitize and normalize a state dictionary to ensure it's valid.
        """
        try:
            # Create a clean state dictionary
            sanitized: dict[str, any] = {}  # Python 3.13.4 syntax
            
            # Handle messages field
            if "messages" in state:
                sanitized["messages"] = StateValidator._sanitize_messages(state["messages"])
            else:
                sanitized["messages"] = []
            
            # Handle string fields with defaults
            sanitized["session_id"] = str(state.get("session_id", f"session_{int(time.time())}")).strip()
            sanitized["user_id"] = str(state.get("user_id", "default_user")).strip()
            sanitized["current_agent"] = str(state.get("current_agent", "")).strip()
            
            # Ensure no empty strings
            if not sanitized["session_id"]:
                sanitized["session_id"] = f"session_{int(time.time())}_{str(uuid.uuid4())[:8]}"
            if not sanitized["user_id"]:
                sanitized["user_id"] = "default_user"
            
            return sanitized
            
        except Exception as e:
            logger.error(f"Error sanitizing state: {e}")
            # Return minimal valid state as fallback
            return {
                "messages": [],
                "session_id": f"fallback_session_{int(time.time())}",
                "user_id": "default_user",
                "current_agent": ""
            }
    
    @staticmethod
    def _sanitize_messages(messages: any) -> list[BaseMessage]:  # Python 3.13.4 syntax
        """Sanitize messages list"""
        if not isinstance(messages, (list, tuple)):
            logger.warning(f"Messages field is not a list/tuple: {type(messages)}")
            return []
        
        sanitized_messages = []
        for i, message in enumerate(messages):
            try:
                if isinstance(message, BaseMessage):
                    # Validate the message content
                    if isinstance(message, AIMessage):
                        # Check if AIMessage has content or tool calls
                        content = getattr(message, 'content', '')
                        tool_calls = getattr(message, 'tool_calls', [])
                        
                        if content.strip() or (tool_calls and len(tool_calls) > 0):
                            sanitized_messages.append(message)
                        else:
                            logger.debug(f"Skipping empty AIMessage {i}")
                    else:
                        # For other message types, just check content
                        content = getattr(message, 'content', '')
                        if content.strip():
                            sanitized_messages.append(message)
                        else:
                            logger.debug(f"Skipping empty message {i}: {type(message)}")
                else:
                    logger.warning(f"Skipping non-BaseMessage object {i}: {type(message)}")
            except Exception as e:
                logger.error(f"Error processing message {i}: {e}")
                continue
        
        return sanitized_messages
    
    @staticmethod
    async def validate_state_async(state: any, strict: bool = False) -> ValidationResult:  # Python 3.13.4 syntax
        """
        Async version of state validation for large states.
        Uses Python 3.13.4 TaskGroup for concurrent validation.
        """
        try:
            # Use TaskGroup for concurrent validation (Python 3.13.4)
            async with asyncio.TaskGroup() as tg:
                # Create validation tasks
                basic_task = tg.create_task(
                    StateValidator._validate_basic_structure_async(state, strict)
                )
                messages_task = tg.create_task(
                    StateValidator._validate_messages_async(state.get("messages", []), strict)
                )
                fields_task = tg.create_task(
                    StateValidator._validate_fields_async(state, strict)
                )
            
            # Combine results
            basic_result = basic_task.result()
            messages_result = messages_task.result()
            fields_result = fields_task.result()
            
            combined_result = ValidationResult(
                is_valid=all([basic_result.is_valid, messages_result.is_valid, fields_result.is_valid]),
                errors=basic_result.errors + messages_result.errors + fields_result.errors,
                warnings=basic_result.warnings + messages_result.warnings + fields_result.warnings,
                metadata={
                    **basic_result.metadata,
                    **messages_result.metadata,
                    **fields_result.metadata,
                    "async_validation": True
                }
            )
            
            return combined_result
            
        except Exception as e:
            logger.error(f"Async validation failed: {e}")
            # Fallback to sync validation
            return StateValidator.validate_state(state, strict)
    
    @staticmethod
    async def _validate_basic_structure_async(state: any, strict: bool) -> ValidationResult:
        """Async validation of basic structure"""
        await asyncio.sleep(0)  # Yield control
        result = ValidationResult(is_valid=True)
        
        if not isinstance(state, dict):
            result.errors.append(f"State must be a dictionary, got {type(state)}")
            result.is_valid = False
        
        result.metadata["structure_validation"] = "completed"
        return result
    
    @staticmethod
    async def _validate_messages_async(messages: any, strict: bool) -> ValidationResult:
        """Async validation of messages"""
        await asyncio.sleep(0)  # Yield control
        return StateValidator._validate_messages(messages, strict)
    
    @staticmethod
    async def _validate_fields_async(state: dict[str, any], strict: bool) -> ValidationResult:  # Python 3.13.4 syntax
        """Async validation of fields"""
        await asyncio.sleep(0)  # Yield control
        result = ValidationResult(is_valid=True)
        
        required_fields = ["messages", "session_id", "user_id", "current_agent"]
        for field in required_fields:
            if field not in state:
                result.errors.append(f"Missing required field: {field}")
                result.is_valid = False
        
        result.metadata["fields_validation"] = "completed"
        return result

def create_optimized_state(
    session_id: str = "",
    user_id: str = "default",
    initial_context: Optional[dict[str, any]] = None,  # Python 3.13.4 syntax
    validate: bool = True
) -> AssistantState:
    """
    Creates a state dictionary that conforms to the AssistantState TypedDict.
    Enhanced for Python 3.13.4 with improved type hints.
    
    Args:
        session_id: Session identifier
        user_id: User identifier  
        initial_context: Initial context to apply to the state
        validate: Whether to validate the resulting state
    """
    
    # Base state data that matches the TypedDict definition
    state_data: dict[str, any] = {  # Python 3.13.4 syntax
        "session_id": session_id or f"session_{int(time.time())}",
        "user_id": user_id,
        "messages": [],
        "current_agent": "",
    }
    
    # Apply initial context
    if initial_context:
        if "messages" in initial_context:
            validated_messages = validate_and_filter_messages(initial_context["messages"])
            state_data["messages"] = validated_messages
        if "current_agent" in initial_context:
            state_data["current_agent"] = str(initial_context["current_agent"])
    
    # Sanitize the state if validation is requested
    if validate:
        state_data = StateValidator.sanitize_state(state_data)
        
        # Perform final validation
        validation_result = StateValidator.validate_state(state_data, strict=False)
        if not validation_result.is_valid:
            logger.warning(f"State validation errors: {validation_result.errors}")
        if validation_result.warnings:
            logger.info(f"State validation warnings: {validation_result.warnings}")
    
    return state_data

def validate_and_filter_messages(messages: list[BaseMessage]) -> list[BaseMessage]:  # Python 3.13.4 syntax
    """
    Validates messages with comprehensive error checking.
    Enhanced for Python 3.13.4 with improved type hints.
    """
    if not messages:
        return []
    
    return StateValidator._sanitize_messages(messages)

def safe_state_access(state: AssistantState, key: str, default: any = None) -> any:  # Python 3.13.4 syntax
    """
    Safely access state fields with fallback values.
    Enhanced with Python 3.13.4 type hints.
    """
    try:
        if not isinstance(state, dict):
            logger.error(f"State is not a dictionary: {type(state)}")
            return default
        
        value = state.get(key, default)
        
        # Type validation for known fields using match-case (Python 3.13.4)
        match key:
            case "messages" if value is not None:
                if not isinstance(value, (list, tuple)):
                    logger.warning(f"Messages field is not a list: {type(value)}")
                    return default if default is not None else []
            case "session_id" | "user_id" | "current_agent" if value is not None:
                if not isinstance(value, str):
                    logger.warning(f"{key} field is not a string: {type(value)}")
                    return str(value) if value is not None else default
        
        return value
        
    except Exception as e:
        logger.error(f"Error accessing state key '{key}': {e}")
        return default

def migrate_legacy_state(old_state: dict[str, any]) -> AssistantState:  # Python 3.13.4 syntax
    """
    Migrate legacy state formats to current TypedDict format.
    Enhanced for Python 3.13.4 with improved type hints and match-case.
    """
    try:
        # Handle different legacy formats using match-case (Python 3.13.4)
        migrated_state = {}
        
        # Basic field migration with enhanced pattern matching
        session_id = old_state.get("session_id") or old_state.get("thread_id")
        match session_id:
            case str() if session_id.strip():
                migrated_state["session_id"] = session_id
            case _:
                migrated_state["session_id"] = f"migrated_session_{int(time.time())}"
        
        migrated_state["user_id"] = str(old_state.get("user_id", "migrated_user"))
        migrated_state["current_agent"] = str(old_state.get("current_agent", ""))
        
        # Messages migration
        messages = old_state.get("messages", [])
        migrated_state["messages"] = validate_and_filter_messages(messages)
        
        logger.info(f"Migrated legacy state with {len(messages)} messages")
        return StateValidator.sanitize_state(migrated_state)
        
    except Exception as e:
        logger.error(f"Error migrating legacy state: {e}")
        # Return minimal valid state
        return create_optimized_state()

def get_state_summary(state: AssistantState) -> dict[str, any]:  # Python 3.13.4 syntax
    """
    Get a summary of the current state for debugging and monitoring.
    Enhanced for Python 3.13.4 with improved type hints.
    """
    try:
        messages = safe_state_access(state, "messages", [])
        
        message_types: dict[str, int] = {}  # Python 3.13.4 syntax
        for msg in messages:
            msg_type = type(msg).__name__
            message_types[msg_type] = message_types.get(msg_type, 0) + 1
        
        validation_result = StateValidator.validate_state(state)
        
        return {
            "session_id": safe_state_access(state, "session_id", "unknown"),
            "user_id": safe_state_access(state, "user_id", "unknown"),
            "current_agent": safe_state_access(state, "current_agent", "none"),
            "message_count": len(messages),
            "message_types": message_types,
            "is_valid": validation_result.is_valid,
            "validation_errors": len(validation_result.errors),
            "validation_warnings": len(validation_result.warnings),
            "state_size_bytes": len(str(state)),
            "summary_timestamp": time.time()
        }
    except Exception as e:
        logger.error(f"Error creating state summary: {e}")
        return {"error": str(e)}

# Aliases for backward compatibility
create_assistant_state = create_optimized_state

def optimize_state_for_processing(
    state: AssistantState, 
    max_messages: int = 20,
    preserve_system_messages: bool = True
) -> AssistantState:
    """
    Optimize state for processing by limiting message history and cleaning up data.
    Enhanced for Python 3.13.4 with improved algorithms and type hints.
    """
    try:
        optimized_state = dict(state) 
        
        # Limit message history to prevent context overflow
        messages = safe_state_access(state, "messages", [])
        if len(messages) > max_messages:
            # Enhanced message preservation logic
            preserved_messages: list[BaseMessage] = []  # Python 3.13.4 syntax
            
            # Always preserve system messages if requested
            if preserve_system_messages:
                system_messages = [msg for msg in messages if isinstance(msg, SystemMessage)]
                preserved_messages.extend(system_messages)
                remaining_slots = max_messages - len(system_messages)
            else:
                remaining_slots = max_messages
            
            # Get the most recent non-system messages
            non_system_messages = [msg for msg in messages if not isinstance(msg, SystemMessage)]
            if remaining_slots > 0 and non_system_messages:
                recent_messages = non_system_messages[-remaining_slots:]
                preserved_messages.extend(recent_messages)
            
            optimized_state["messages"] = preserved_messages
            logger.debug(f"Optimized messages from {len(messages)} to {len(preserved_messages)}")
        
        return optimized_state
        
    except Exception as e:
        logger.error(f"Error optimizing state: {e}")
        return state

async def compress_state_async(state: AssistantState, compression_level: int = 1) -> AssistantState:
    """
    Async state compression for large conversation histories.
    Uses Python 3.13.4 TaskGroup for concurrent processing.
    """
    try:
        async with asyncio.TaskGroup() as tg:
            # Create compression tasks
            messages_task = tg.create_task(
                _compress_messages_async(state.get("messages", []), compression_level)
            )
            metadata_task = tg.create_task(
                _compress_metadata_async(state, compression_level)
            )
        
        compressed_state = dict(state)
        compressed_state["messages"] = messages_task.result()
        compressed_state.update(metadata_task.result())
        
        return compressed_state
        
    except Exception as e:
        logger.error(f"Async compression failed: {e}")
        return state

async def _compress_messages_async(messages: list[BaseMessage], level: int) -> list[BaseMessage]:  # Python 3.13.4 syntax
    """Compress messages based on level"""
    await asyncio.sleep(0)  # Yield control
    
    if level == 1:
        # Light compression: remove duplicate consecutive messages
        compressed = []
        last_content = None
        for msg in messages:
            content = getattr(msg, 'content', '')
            if content != last_content:
                compressed.append(msg)
                last_content = content
        return compressed
    elif level == 2:
        # Medium compression: summarize old messages (placeholder)
        return messages[-50:] if len(messages) > 50 else messages
    else:
        # Heavy compression: keep only recent messages
        return messages[-20:] if len(messages) > 20 else messages

async def _compress_metadata_async(state: dict[str, any], level: int) -> dict[str, any]:  # Python 3.13.4 syntax
    """Compress metadata based on level"""
    await asyncio.sleep(0)  # Yield control
    
    metadata = {
        "compression_level": level,
        "compression_timestamp": time.time(),
        "original_message_count": len(state.get("messages", []))
    }
    
    return metadata

# core/checkpointer.py - ✅ ENHANCED WITH PYTHON 3.13.4 COMPATIBILITY
import os
import asyncio
import sqlite3
import time
import logging
from pathlib import Path
from typing import Optional, Union, Any
from collections.abc import Mapping  # Python 3.13.4 preferred import
from dataclasses import dataclass, field
from enum import Enum
from asyncio import TaskGroup  # Python 3.13.4 TaskGroup

from langgraph.checkpoint.memory import MemorySaver

logger = logging.getLogger("checkpointer")

class CheckpointerType(Enum):
    """Types of checkpointers available"""
    MEMORY = "memory"
    SQLITE_SYNC = "sqlite_sync"
    SQLITE_ASYNC = "sqlite_async"
    POSTGRES_SYNC = "postgres_sync"
    POSTGRES_ASYNC = "postgres_async"

class Environment(Enum):
    """Environment types for checkpointer selection"""
    DEVELOPMENT = "development"
    STAGING = "staging"
    PRODUCTION = "production"
    TESTING = "testing"

@dataclass
class CheckpointerConfig:
    """Configuration for checkpointer creation with Python 3.13.4 enhancements"""
    environment: Environment = Environment.DEVELOPMENT
    prefer_async: bool = True
    connection_timeout: float = 30.0
    retry_attempts: int = 3
    health_check_interval: float = 300.0  # 5 minutes
    backup_enabled: bool = True
    compression_enabled: bool = False
    pool_size: int = 5
    max_overflow: int = 10
    
    def __post_init__(self):
        """Validate configuration parameters"""
        if self.connection_timeout <= 0:
            raise ValueError("connection_timeout must be positive")
        if self.retry_attempts < 0:
            raise ValueError("retry_attempts cannot be negative")

@dataclass
class CheckpointerHealth:
    """Health status of a checkpointer with enhanced metrics"""
    is_healthy: bool
    checkpointer_type: CheckpointerType
    connection_status: str
    last_check: float = field(default_factory=time.time)
    response_time_ms: float = 0.0
    error_count: int = 0
    success_count: int = 0
    metadata: dict[str, any] = field(default_factory=dict)  # Python 3.13.4 syntax
    
    def get_health_score(self) -> float:
        """Calculate health score (0.0 to 1.0)"""
        if self.success_count + self.error_count == 0:
            return 1.0
        return self.success_count / (self.success_count + self.error_count)

class CheckpointerFactory:
    """
    Enhanced factory for creating modern checkpointers using LangGraph 0.4.8 with Python 3.13.4 features.
    """
    
    def __init__(self, config: Optional[CheckpointerConfig] = None):
        self.config = config or CheckpointerConfig()
        self._health_status: dict[str, CheckpointerHealth] = {}  # Python 3.13.4 syntax
        self._connection_cache: dict[str, any] = {}  # Python 3.13.4 syntax
        
    @classmethod
    async def create_optimal_checkpointer(
        cls, 
        config: Optional[CheckpointerConfig] = None
    ) -> any:  # Python 3.13.4 syntax
        """
        Factory method that returns the best available checkpointer with enhanced logic.
        """
        factory = cls(config)
        environment = factory._detect_environment()
        
        logger.info(f"Creating optimal checkpointer for environment: {environment.value}")
        
        # Enhanced selection logic using match-case (Python 3.13.4)
        match environment:
            case Environment.PRODUCTION:
                return await factory._create_production_checkpointer()
            case Environment.STAGING:
                return await factory._create_staging_checkpointer()
            case Environment.TESTING:
                return await factory._create_testing_checkpointer()
            case Environment.DEVELOPMENT:
                return await factory._create_development_checkpointer()
            case _:
                logger.warning(f"Unknown environment {environment}, using development checkpointer")
                return await factory._create_development_checkpointer()
    
    async def _create_production_checkpointer(self) -> any:  # Python 3.13.4 syntax
        """Create production-grade checkpointer with failover"""
        try:
            # Try async PostgreSQL first (preferred for production)
            if self.config.prefer_async:
                checkpointer = await self._create_async_postgres_checkpointer()
                if await self._validate_checkpointer(checkpointer, CheckpointerType.POSTGRES_ASYNC):
                    return checkpointer
            
            # Fallback to sync PostgreSQL
            checkpointer = await self._create_postgres_checkpointer_sync()
            if await self._validate_checkpointer(checkpointer, CheckpointerType.POSTGRES_SYNC):
                return checkpointer
            
            # Final fallback to SQLite with warning
            logger.warning("⚠️ Production environment falling back to SQLite - not recommended!")
            return await self._create_sqlite_checkpointer_with_backup()
            
        except Exception as e:
            logger.error(f"Production checkpointer creation failed: {e}")
            return await self._create_memory_checkpointer_with_warning()
    
    async def _create_staging_checkpointer(self) -> any:  # Python 3.13.4 syntax
        """Create staging checkpointer (similar to production but more lenient)"""
        try:
            # Try PostgreSQL first, then SQLite
            if postgres_checkpointer := await self._try_postgres_checkpointer():
                return postgres_checkpointer
            
            return await self._create_sqlite_checkpointer_with_backup()
            
        except Exception as e:
            logger.error(f"Staging checkpointer creation failed: {e}")
            return await self._create_memory_checkpointer_with_warning()
    
    async def _create_development_checkpointer(self) -> any:  # Python 3.13.4 syntax
        """Create development checkpointer (SQLite preferred)"""
        try:
            if self.config.prefer_async:
                return await self._create_async_sqlite_checkpointer()
            else:
                return await self._create_sqlite_checkpointer_sync()
        except Exception as e:
            logger.error(f"Development checkpointer creation failed: {e}")
            return MemorySaver()
    
    async def _create_testing_checkpointer(self) -> any:  # Python 3.13.4 syntax
        """Create testing checkpointer (memory preferred for speed)"""
        return MemorySaver()
    
    async def _try_postgres_checkpointer(self) -> Optional[any]:  # Python 3.13.4 syntax
        """Try to create PostgreSQL checkpointer with both async and sync fallback"""
        if self.config.prefer_async:
            try:
                checkpointer = await self._create_async_postgres_checkpointer()
                if await self._validate_checkpointer(checkpointer, CheckpointerType.POSTGRES_ASYNC):
                    return checkpointer
            except Exception as e:
                logger.debug(f"Async PostgreSQL failed: {e}")
        
        try:
            checkpointer = await self._create_postgres_checkpointer_sync()
            if await self._validate_checkpointer(checkpointer, CheckpointerType.POSTGRES_SYNC):
                return checkpointer
        except Exception as e:
            logger.debug(f"Sync PostgreSQL failed: {e}")
        
        return None
    
    async def _create_async_postgres_checkpointer(self) -> any:  # Python 3.13.4 syntax
        """
        Creates async PostgreSQL checkpointer using psycopg_pool library.
        Enhanced with Python 3.13.4 features and better error handling.
        """
        try:
            from psycopg_pool import AsyncConnectionPool
            from langgraph.checkpoint.postgres.aio import AsyncPostgresSaver
            
            conn_str = os.getenv("POSTGRES_URL")
            if not conn_str:
                raise ValueError("POSTGRES_URL not set for async PostgreSQL checkpointer")
            
            # Enhanced connection configuration
            pool_config = {
                "conninfo": conn_str,
                "min_size": 1,
                "max_size": self.config.pool_size,
                "timeout": self.config.connection_timeout,
                "max_idle": 300.0,  # 5 minutes
                "max_lifetime": 3600.0,  # 1 hour
            }
            
            pool = AsyncConnectionPool(**pool_config)
            
            # Test connection with timeout
            await asyncio.wait_for(
                self._test_async_postgres_connection(pool),
                timeout=self.config.connection_timeout
            )
            
            checkpointer = AsyncPostgresSaver(conn=pool)
            await checkpointer.setup()
            
            # Cache the connection for reuse
            self._connection_cache["postgres_async"] = pool
            
            logger.info("✅ Async PostgreSQL checkpointer created successfully")
            return checkpointer
            
        except ImportError as e:
            logger.error(f"❌ Required packages missing for async PostgreSQL: {e}")
            logger.info("💡 Install with: pip install 'psycopg[binary]' psycopg-pool")
            raise
        except Exception as e:
            logger.error(f"❌ Async PostgreSQL checkpointer creation failed: {e}")
            raise
    
    async def _create_postgres_checkpointer_sync(self) -> any:  # Python 3.13.4 syntax
        """Create synchronous PostgreSQL checkpointer with enhanced error handling"""
        try:
            from langgraph.checkpoint.postgres import PostgresSaver
            import psycopg2
            from psycopg2 import pool
            
            conn_str = os.getenv("POSTGRES_URL")
            if not conn_str:
                raise ValueError("POSTGRES_URL not set for sync PostgreSQL checkpointer")
            
            # Test connection first
            if not await self._test_postgres_connection_sync():
                raise ConnectionError("PostgreSQL connection test failed")
            
            # Create connection with enhanced configuration
            conn = psycopg2.connect(
                conn_str,
                connect_timeout=int(self.config.connection_timeout)
            )
            
            # Configure connection
            conn.autocommit = True
            
            checkpointer = PostgresSaver(conn=conn)
            
            # Cache the connection
            self._connection_cache["postgres_sync"] = conn
            
            logger.info("✅ Sync PostgreSQL checkpointer created successfully")
            return checkpointer
            
        except ImportError as e:
            logger.error(f"❌ psycopg2-binary not installed: {e}")
            logger.info("💡 Install with: pip install psycopg2-binary")
            raise
        except Exception as e:
            logger.error(f"❌ Sync PostgreSQL checkpointer creation failed: {e}")
            raise
    
    async def _create_async_sqlite_checkpointer(self) -> any:  # Python 3.13.4 syntax
        """Create async SQLite checkpointer with enhanced features"""
        try:
            from langgraph.checkpoint.sqlite.aio import AsyncSqliteSaver
            import aiosqlite
            from config.settings import config
            
            # Ensure workspace directory exists
            config.workspace_dir.mkdir(parents=True, exist_ok=True)
            
            # Determine database path
            db_path = self._get_sqlite_path()
            
            logger.info(f"Creating async SQLite checkpointer at: {db_path}")
            
            # Enhanced connection configuration
            conn = await aiosqlite.connect(
                str(db_path),
                timeout=self.config.connection_timeout,
                isolation_level=None  # Autocommit mode
            )
            
            # Configure SQLite for better performance
            await conn.execute("PRAGMA journal_mode=WAL")
            await conn.execute("PRAGMA synchronous=NORMAL")
            await conn.execute("PRAGMA cache_size=10000")
            await conn.execute("PRAGMA temp_store=MEMORY")
            
            checkpointer = AsyncSqliteSaver(conn=conn)
            
            # Cache the connection
            self._connection_cache["sqlite_async"] = conn
            
            logger.info(f"✅ Async SQLite checkpointer created at: {db_path}")
            return checkpointer
            
        except ImportError as e:
            logger.error(f"❌ Async SQLite dependencies not available: {e}")
            logger.info("💡 Install with: pip install aiosqlite")
            raise
        except Exception as e:
            logger.error(f"❌ Async SQLite checkpointer creation failed: {e}")
            raise
    
    async def _create_sqlite_checkpointer_sync(self) -> any:  # Python 3.13.4 syntax
        """Create synchronous SQLite checkpointer with enhanced features"""
        try:
            from langgraph.checkpoint.sqlite import SqliteSaver
            from config.settings import config
            
            # Ensure workspace directory exists
            config.workspace_dir.mkdir(parents=True, exist_ok=True)
            
            # Determine database path
            db_path = self._get_sqlite_path()
            
            logger.info(f"Creating sync SQLite checkpointer at: {db_path}")
            
            # Enhanced connection configuration
            conn = sqlite3.connect(
                str(db_path),
                check_same_thread=False,
                timeout=self.config.connection_timeout,
                isolation_level=None  # Autocommit mode
            )
            
            # Configure SQLite for better performance
            conn.execute("PRAGMA journal_mode=WAL")
            conn.execute("PRAGMA synchronous=NORMAL")
            conn.execute("PRAGMA cache_size=10000")
            conn.execute("PRAGMA temp_store=MEMORY")
            
            checkpointer = SqliteSaver(conn=conn)
            
            # Cache the connection
            self._connection_cache["sqlite_sync"] = conn
            
            logger.info(f"✅ Sync SQLite checkpointer created at: {db_path}")
            return checkpointer
            
        except Exception as e:
            logger.error(f"❌ Sync SQLite checkpointer creation failed: {e}")
            raise
    
    async def _create_sqlite_checkpointer_with_backup(self) -> any:  # Python 3.13.4 syntax
        """Create SQLite checkpointer with backup capabilities"""
        checkpointer = await self._create_async_sqlite_checkpointer()
        
        if self.config.backup_enabled:
            await self._setup_sqlite_backup()
        
        return checkpointer
    
    async def _create_memory_checkpointer_with_warning(self) -> MemorySaver:
        """Create memory checkpointer with appropriate warnings"""
        logger.warning("⚠️ Using MemorySaver - conversation history will not persist!")
        logger.warning("⚠️ This is not recommended for production use!")
        return MemorySaver()
    
    def _get_sqlite_path(self) -> Path:
        """Get SQLite database path with enhanced logic"""
        from config.settings import config
        
        # Check for explicit DATABASE_URL
        database_url = os.getenv("DATABASE_URL")
        if database_url and database_url.startswith("sqlite:///"):
            return Path(database_url.replace("sqlite:///", ""))
        
        # Use workspace directory
        db_name = f"assistant_{self.config.environment.value}.db"
        return config.workspace_dir / db_name
    
    def _detect_environment(self) -> Environment:
        """Enhanced environment detection with Python 3.13.4 match-case"""
        # Check explicit environment variable
        env_var = os.getenv("ENVIRONMENT", "").lower()
        
        # Enhanced environment detection using match-case (Python 3.13.4)
        match env_var:
            case "production" | "prod":
                return Environment.PRODUCTION
            case "staging" | "stage":
                return Environment.STAGING
            case "testing" | "test":
                return Environment.TESTING
            case "development" | "dev":
                return Environment.DEVELOPMENT
        
        # Auto-detect based on available services
        postgres_url = os.getenv("POSTGRES_URL")
        if postgres_url:
            logger.info("PostgreSQL URL detected, assuming production environment")
            return Environment.PRODUCTION
        
        # Check for common CI/testing indicators
        ci_indicators = ["CI", "GITHUB_ACTIONS", "TRAVIS", "JENKINS", "GITLAB_CI"]
        if any(os.getenv(indicator) for indicator in ci_indicators):
            logger.info("CI environment detected, using testing mode")
            return Environment.TESTING
        
        logger.info("No explicit environment indicators, defaulting to development")
        return Environment.DEVELOPMENT
    
    async def _test_async_postgres_connection(self, pool) -> bool:
        """Test async PostgreSQL connection"""
        try:
            async with pool.connection() as conn:
                async with conn.cursor() as cursor:
                    await cursor.execute("SELECT 1")
                    result = await cursor.fetchone()
                    return result[0] == 1
        except Exception as e:
            logger.error(f"Async PostgreSQL connection test failed: {e}")
            return False
    
    async def _test_postgres_connection_sync(self) -> bool:
        """Test PostgreSQL connection using psycopg2 for sync operations"""
        try:
            import psycopg2
            
            conn_str = os.getenv("POSTGRES_URL")
            if not conn_str:
                logger.warning("POSTGRES_URL not set for connection test")
                return False
            
            # Test connection with timeout
            conn = psycopg2.connect(
                conn_str, 
                connect_timeout=int(self.config.connection_timeout)
            )
            cursor = conn.cursor()
            cursor.execute("SELECT 1")
            result = cursor.fetchone()
            cursor.close()
            conn.close()
            
            logger.info("✅ PostgreSQL connection test successful")
            return result[0] == 1
            
        except Exception as e:
            logger.error(f"❌ PostgreSQL connection test failed: {e}")
            return False
    
    async def _validate_checkpointer(
        self, 
        checkpointer: any,  # Python 3.13.4 syntax
        checkpointer_type: CheckpointerType
    ) -> bool:
        """Validate checkpointer functionality"""
        try:
            start_time = time.time()
            
            # Basic validation - try to use the checkpointer
            if hasattr(checkpointer, 'alist'):
                # Test listing (should not fail)
                await asyncio.wait_for(
                    checkpointer.alist({}),
                    timeout=5.0
                )
            
            response_time = (time.time() - start_time) * 1000
            
            # Record health status
            self._health_status[checkpointer_type.value] = CheckpointerHealth(
                is_healthy=True,
                checkpointer_type=checkpointer_type,
                connection_status="connected",
                response_time_ms=response_time,
                success_count=1
            )
            
            return True
            
        except Exception as e:
            logger.error(f"Checkpointer validation failed for {checkpointer_type.value}: {e}")
            
            # Record health status
            self._health_status[checkpointer_type.value] = CheckpointerHealth(
                is_healthy=False,
                checkpointer_type=checkpointer_type,
                connection_status="failed",
                error_count=1,
                metadata={"error": str(e)}
            )
            
            return False
    
    async def _setup_sqlite_backup(self) -> None:
        """Setup SQLite backup mechanism"""
        try:
            from config.settings import config
            
            backup_dir = config.workspace_dir / "backups"
            backup_dir.mkdir(exist_ok=True)
            
            # Create backup filename with timestamp
            timestamp = time.strftime("%Y%m%d_%H%M%S")
            backup_file = backup_dir / f"assistant_backup_{timestamp}.db"
            
            # Copy current database if it exists
            db_path = self._get_sqlite_path()
            if db_path.exists():
                import shutil
                shutil.copy2(db_path, backup_file)
                logger.info(f"✅ SQLite backup created: {backup_file}")
            
        except Exception as e:
            logger.warning(f"SQLite backup setup failed: {e}")
    
    async def health_check_all(self) -> dict[str, CheckpointerHealth]:  # Python 3.13.4 syntax
        """Perform health check on all cached checkpointers using TaskGroup"""
        try:
            async with TaskGroup() as tg:
                tasks = {
                    name: tg.create_task(self._health_check_connection(name, conn))
                    for name, conn in self._connection_cache.items()
                }
            
            results = {}
            for name, task in tasks.items():
                try:
                    results[name] = task.result()
                except Exception as e:
                    logger.error(f"Health check failed for {name}: {e}")
                    results[name] = CheckpointerHealth(
                        is_healthy=False,
                        checkpointer_type=CheckpointerType.MEMORY,
                        connection_status="error",
                        error_count=1,
                        metadata={"error": str(e)}
                    )
            
            return results
            
        except Exception as e:
            logger.error(f"Health check batch failed: {e}")
            return {}
    
    async def _health_check_connection(self, name: str, connection: any) -> CheckpointerHealth:  # Python 3.13.4 syntax
        """Health check for individual connection"""
        start_time = time.time()
        
        try:
            # Enhanced health check using match-case (Python 3.13.4)
            match name:
                case name if "postgres" in name:
                    await self._health_check_postgres(connection, name)
                case name if "sqlite" in name:
                    await self._health_check_sqlite(connection, name)
                case _:
                    # Generic health check
                    await asyncio.sleep(0.1)
            
            response_time = (time.time() - start_time) * 1000
            
            return CheckpointerHealth(
                is_healthy=True,
                checkpointer_type=CheckpointerType(name.split("_")[0]),
                connection_status="healthy",
                response_time_ms=response_time,
                success_count=1
            )
            
        except Exception as e:
            response_time = (time.time() - start_time) * 1000
            
            return CheckpointerHealth(
                is_healthy=False,
                checkpointer_type=CheckpointerType.MEMORY,
                connection_status="unhealthy",
                response_time_ms=response_time,
                error_count=1,
                metadata={"error": str(e)}
            )
    
    async def _health_check_postgres(self, connection: any, name: str) -> None:  # Python 3.13.4 syntax
        """Health check for PostgreSQL connection"""
        if "async" in name:
            async with connection.connection() as conn:
                async with conn.cursor() as cursor:
                    await cursor.execute("SELECT 1")
                    await cursor.fetchone()
        else:
            cursor = connection.cursor()
            cursor.execute("SELECT 1")
            cursor.fetchone()
            cursor.close()
    
    async def _health_check_sqlite(self, connection: any, name: str) -> None:  # Python 3.13.4 syntax
        """Health check for SQLite connection"""
        if "async" in name:
            await connection.execute("SELECT 1")
        else:
            connection.execute("SELECT 1")
    
    def get_health_summary(self) -> dict[str, any]:  # Python 3.13.4 syntax
        """Get comprehensive health summary"""
        healthy_count = sum(1 for health in self._health_status.values() if health.is_healthy)
        total_count = len(self._health_status)
        
        return {
            "overall_health": healthy_count / max(total_count, 1),
            "healthy_connections": healthy_count,
            "total_connections": total_count,
            "connection_details": {
                name: {
                    "healthy": health.is_healthy,
                    "type": health.checkpointer_type.value,
                    "response_time_ms": health.response_time_ms,
                    "health_score": health.get_health_score()
                }
                for name, health in self._health_status.items()
            },
            "environment": self.config.environment.value,
            "config": {
                "prefer_async": self.config.prefer_async,
                "connection_timeout": self.config.connection_timeout,
                "backup_enabled": self.config.backup_enabled
            }
        }
    
    async def cleanup_connections(self) -> None:
        """Cleanup all cached connections"""
        try:
            async with TaskGroup() as tg:
                cleanup_tasks = [
                    tg.create_task(self._cleanup_connection(name, conn))
                    for name, conn in self._connection_cache.items()
                ]
            
            self._connection_cache.clear()
            self._health_status.clear()
            logger.info("✅ All checkpointer connections cleaned up")
            
        except Exception as e:
            logger.error(f"Connection cleanup failed: {e}")
    
    async def _cleanup_connection(self, name: str, connection: any) -> None:  # Python 3.13.4 syntax
        """Cleanup individual connection"""
        try:
            if hasattr(connection, 'close'):
                if asyncio.iscoroutinefunction(connection.close):
                    await connection.close()
                else:
                    connection.close()
            logger.debug(f"✅ Cleaned up connection: {name}")
        except Exception as e:
            logger.warning(f"Failed to cleanup connection {name}: {e}")

# Convenience functions for backward compatibility
async def create_optimal_checkpointer(config: Optional[CheckpointerConfig] = None) -> any:  # Python 3.13.4 syntax
    """Create the best available checkpointer for the current environment"""
    return await CheckpointerFactory.create_optimal_checkpointer(config)

async def create_development_checkpointer() -> any:  # Python 3.13.4 syntax
    """Create checkpointer suitable for development"""
    config = CheckpointerConfig(environment=Environment.DEVELOPMENT)
    factory = CheckpointerFactory(config)
    return await factory._create_development_checkpointer()

async def create_production_checkpointer() -> any:  # Python 3.13.4 syntax
    """Create checkpointer suitable for production"""
    config = CheckpointerConfig(environment=Environment.PRODUCTION)
    factory = CheckpointerFactory(config)
    return await factory._create_production_checkpointer()

def create_memory_checkpointer() -> MemorySaver:
    """Create memory checkpointer (no persistence)"""
    logger.warning("⚠️ Using MemorySaver - no conversation persistence!")
    return MemorySaver()

# Global factory instance for convenience
_global_factory: Optional[CheckpointerFactory] = None

def get_global_factory() -> CheckpointerFactory:
    """Get or create global checkpointer factory"""
    global _global_factory
    if _global_factory is None:
        _global_factory = CheckpointerFactory()
    return _global_factory

async def health_check_checkpointers() -> dict[str, CheckpointerHealth]:  # Python 3.13.4 syntax
    """Perform health check on all checkpointers"""
    factory = get_global_factory()
    return await factory.health_check_all()

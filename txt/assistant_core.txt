# core/assistant_core.py - âœ… Full Integration with Python 3.13.4 Features
import asyncio
import signal
import uuid
import logging
from typing import Dict, Any, Optional
from dataclasses import dataclass
from contextlib import asynccontextmanager

from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from fastapi.staticfiles import StaticFiles
from fastapi.responses import HTMLResponse
from sse_starlette.sse import EventSourceResponse

from core.state import AssistantState
from core.supervisor import Supervisor
from agents.agents import agent_factory, get_agent
from core.checkpointer import create_optimal_checkpointer, health_check_checkpointers
from core.error_handling import ErrorHandler, handle_error
from core.circuit_breaker import global_circuit_breaker
from config.llm_manager import llm_manager
from config.settings import config

logger = logging.getLogger("assistant_core")

class AssistantCore:
    """Main assistant class integrating all components with Python 3.13.4 enhancements"""
    
    def __init__(self):
        self.app = FastAPI(lifespan=self.lifespan)
        self.supervisor = Supervisor()
        self.checkpointer = None
        self.active_sessions: Dict[str, AssistantState] = {}
        self._setup_routes()
        
    @asynccontextmanager
    async def lifespan(self, app: FastAPI):
        """Async context manager for component lifecycle"""
        await self.initialize()
        yield
        await self.graceful_shutdown()
    
    async def initialize(self):
        """Initialize all components with enhanced error handling"""
        try:
            logger.info("ðŸš€ Starting Assistant Core Initialization")
            
            # Initialize checkpointer
            self.checkpointer = await create_optimal_checkpointer()
            
            # Initialize agents first
            agents = await agent_factory.initialize_agents()
            
            # Get all tools
            all_tools = agent_factory.get_all_tools()
            
            # Initialize supervisor with required arguments
            await self.supervisor.initialize(agents, all_tools, self.checkpointer)
            
            # Start background tasks
            asyncio.create_task(self._session_cleanup_task())
            asyncio.create_task(self._health_monitoring_task())
            
            logger.info("âœ… Assistant Core Initialization Complete")
            
        except Exception as e:
            logger.error(f"âŒ Initialization failed: {e}")
            await self.graceful_shutdown()
            raise
    
    async def graceful_shutdown(self):
        """Shutdown all components gracefully"""
        logger.info("ðŸ”Œ Starting graceful shutdown...")
        
        # Close checkpointer
        if self.checkpointer:
            await self.checkpointer.cleanup_connections()
        
        # Close LLM manager
        if hasattr(llm_manager, 'close'):
            await llm_manager.close()
        
        # Close circuit breakers
        await global_circuit_breaker.stop_monitoring()
        
        logger.info("âœ… Graceful shutdown completed")
    
    def _setup_routes(self):
        """Configure FastAPI routes"""
        self.app.mount("/static", StaticFiles(directory="static"), name="static")
        
        @self.app.get("/", response_class=HTMLResponse)
        async def web_interface():
            return self._get_web_interface()
        
        @self.app.websocket("/ws")
        async def websocket_endpoint(websocket: WebSocket):
            await self._handle_websocket(websocket)
        
        @self.app.post("/api/message")
        async def handle_message(message: dict):
            return await self._handle_api_message(message)
        
        @self.app.get("/api/status")
        async def get_system_status():
            return await self._get_system_status()
    
    async def _handle_websocket(self, websocket: WebSocket):
        """Handle WebSocket connections"""
        await websocket.accept()
        session_id = str(uuid.uuid4())
        
        try:
            while True:
                message = await websocket.receive_json()
                response = await self.process_message(
                    message.get("content", ""),
                    session_id=session_id,
                    user_id=message.get("user_id", "anonymous")
                )
                await websocket.send_json(response)
        except WebSocketDisconnect:
            logger.info(f"WebSocket disconnected: {session_id}")
        except Exception as e:
            error_response = await handle_error(e, "websocket_handler")
            await websocket.send_json(error_response)
        
    async def process_message(
        self,
        message: str,
        session_id: Optional[str] = None,
        user_id: str = "anonymous"
    ) -> Dict[str, Any]:
        """Main message processing pipeline with enhanced safety"""
        try:
            # Get or create session state
            session_state = await self._get_session_state(session_id, user_id)
            
            # Add new message to state
            from langchain_core.messages import HumanMessage
            new_messages = list(session_state.get("messages", [])) + [HumanMessage(content=message)]
            
            updated_state = {
                "messages": new_messages,
                "session_id": session_state["session_id"],
                "user_id": session_state["user_id"],
                "current_agent": session_state.get("current_agent", "chat")
            }
            
            # Process through supervisor with proper LangGraph config
            config = {"configurable": {"thread_id": session_state["session_id"]}}
            
            # Call supervisor graph directly instead of supervisor.process
            result = await self.supervisor.supervisor_graph.ainvoke(updated_state, config)
            
            # Update session state
            self.active_sessions[session_state["session_id"]] = result
            
            # Extract response from result
            if isinstance(result, dict) and "messages" in result:
                last_message = result["messages"][-1]
                response_content = getattr(last_message, 'content', str(last_message))
            else:
                response_content = str(result)
            
            return {
                "response": response_content,
                "session_id": session_state["session_id"],
                "timestamp": time.time()
            }
            
        except Exception as e:
            logger.error(f"Message processing failed: {e}")
            return await handle_error(e, "message_processing")

    
    async def _get_session_state(
        self,
        session_id: Optional[str],
        user_id: str
    ) -> AssistantState:
        """Get or create session state with checkpointer integration"""
        if not session_id or session_id not in self.active_sessions:
            new_session_id = session_id or str(uuid.uuid4())
            
            if self.checkpointer and session_id:
                # Try to load existing session
                state = await self.checkpointer.aget({"session_id": session_id})
                if state:
                    self.active_sessions[session_id] = state
                    return state
            
            # Create new session
            new_state = AssistantState(
                session_id=new_session_id,
                user_id=user_id,
                messages=[],
                current_agent="chat"
            )
            self.active_sessions[new_session_id] = new_state
            return new_state
        
        return self.active_sessions[session_id]
    
    async def _get_system_status(self) -> Dict[str, Any]:
        """Get comprehensive system status"""
        try:
            async with asyncio.TaskGroup() as tg:
                agent_status = tg.create_task(agent_factory.health_check_agents())
                circuit_status = tg.create_task(global_circuit_breaker.health_check_all_services())
                checkpointer_status = tg.create_task(health_check_checkpointers())
                llm_status = tg.create_task(llm_manager.health_check())
            
            return {
                "agents": agent_status.result(),
                "circuit_breakers": circuit_status.result(),
                "checkpointer": checkpointer_status.result(),
                "llm_manager": llm_status.result(),
                "active_sessions": len(self.active_sessions),
                "versions": {
                    "python": "3.13.4",
                    "langgraph": "0.4.8",
                    "postgres": "17"
                }
            }
        except Exception as e:
            return await handle_error(e, "status_check")
    
    async def _session_cleanup_task(self):
        """Background task to clean up expired sessions"""
        while True:
            try:
                expired = [
                    session_id for session_id, state in self.active_sessions.items()
                    if state.is_expired()
                ]
                
                for session_id in expired:
                    del self.active_sessions[session_id]
                    if self.checkpointer:
                        await self.checkpointer.adelete(session_id)
                
                logger.info(f"Cleaned up {len(expired)} expired sessions")
                await asyncio.sleep(300)  # 5 minutes
            except Exception as e:
                logger.error(f"Session cleanup error: {e}")
                await asyncio.sleep(60)
    
    async def _health_monitoring_task(self):
        """Background health monitoring task"""
        while True:
            try:
                status = await self._get_system_status()
                if status.get("overall_health", 1.0) < 0.7:
                    logger.warning("System health degraded - triggering recovery")
                    await self._trigger_health_recovery()
                
                await asyncio.sleep(60)
            except Exception as e:
                logger.error(f"Health monitoring error: {e}")
                await asyncio.sleep(30)
    
    async def _trigger_health_recovery(self):
        """Attempt system health recovery"""
        try:
            # Cycle critical components
            await global_circuit_breaker.stop_monitoring()
            await agent_factory.initialize_agents()
            await global_circuit_breaker.start_monitoring()
            
            # Reset LLM manager cache
            if hasattr(llm_manager, 'clear_cache'):
                llm_manager.clear_cache()
            
            logger.info("âœ… Completed health recovery cycle")
        except Exception as e:
            logger.error(f"Health recovery failed: {e}")
    
    def _get_web_interface(self) -> str:
        """Return simple web interface HTML"""
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <title>Mortey Assistant</title>
            <style>
                /* Add your CSS styles here */
            </style>
        </head>
        <body>
            <div id="chat-container"></div>
            <input type="text" id="message-input">
            <button onclick="sendMessage()">Send</button>
            <script>
                const ws = new WebSocket('ws://' + window.location.host + '/ws');
                
                function sendMessage() {
                    const input = document.getElementById('message-input');
                    ws.send(JSON.stringify({content: input.value}));
                    input.value = '';
                }
                
                ws.onmessage = function(event) {
                    const response = JSON.parse(event.data);
                    const chatDiv = document.getElementById('chat-container');
                    chatDiv.innerHTML += `<div class="message">${response.response}</div>`;
                };
            </script>
        </body>
        </html>
        """

# Singleton instance
assistant = AssistantCore()

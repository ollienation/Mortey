# core/error_handling.py - âœ… ENHANCED WITH PYTHON 3.13.4 COMPATIBILITY
from typing import Optional, Union, Callable, Awaitable, Type
from collections.abc import Set, Mapping  # Python 3.13.4 preferred import
from dataclasses import dataclass, field
from enum import Enum
import logging
import asyncio
import inspect
import time
import json
from collections import defaultdict, deque
from functools import wraps
from asyncio import TaskGroup  # Python 3.13.4 TaskGroup

logger = logging.getLogger("error_handling")

class ErrorType(Enum):
    """Comprehensive error types for intelligent classification"""
    EMPTY_CONTENT = "empty_content"
    RATE_LIMIT = "rate_limit"
    CONNECTION_ERROR = "connection_error"
    SUPERVISOR_ERROR = "supervisor_error"
    VALIDATION_ERROR = "validation_error"
    LLM_ERROR = "llm_error"
    TOOL_ERROR = "tool_error"
    SYSTEM_ERROR = "system_error"
    TIMEOUT_ERROR = "timeout_error"
    CONTEXT_MANAGER_ERROR = "context_manager_error"
    CHECKPOINTER_ERROR = "checkpointer_error"
    STATE_ERROR = "state_error"
    AUTHENTICATION_ERROR = "authentication_error"
    QUOTA_EXCEEDED = "quota_exceeded"
    MODEL_OVERLOADED = "model_overloaded"
    CONFIGURATION_ERROR = "configuration_error"
    DEPENDENCY_ERROR = "dependency_error"
    NETWORK_ERROR = "network_error"
    PERMISSION_ERROR = "permission_error"
    RESOURCE_EXHAUSTED = "resource_exhausted"

@dataclass
class ErrorPattern:
    """Pattern for intelligent error classification with Python 3.13.4 enhancements"""
    exception_types: set[Type[Exception]]  # Python 3.13.4 syntax
    string_patterns: set[str]  # Python 3.13.4 syntax
    error_type: ErrorType
    retryable: bool
    priority: int = 1  # Higher priority patterns are checked first
    recovery_time: float = 30.0  # Suggested recovery time in seconds
    
    def matches(self, error: Exception, error_str: str) -> bool:
        """Check if this pattern matches the given error"""
        type_match = type(error) in self.exception_types
        string_match = any(pattern in error_str for pattern in self.string_patterns)
        return type_match or string_match

@dataclass
class CircuitBreakerState:
    """Circuit breaker state for external API calls with enhanced tracking"""
    failure_count: int = 0
    last_failure_time: float = 0
    state: str = "closed"  # closed, open, half_open
    failure_threshold: int = 5
    recovery_timeout: float = 60.0
    call_timeout: float = 30.0
    success_count: int = 0
    total_calls: int = 0
    
    def should_allow_call(self) -> bool:
        """Check if calls should be allowed based on circuit breaker state"""
        current_time = time.time()
        
        match self.state:  # Python 3.13.4 match-case
            case "closed":
                return True
            case "open":
                if current_time - self.last_failure_time >= self.recovery_timeout:
                    self.state = "half_open"
                    return True
                return False
            case "half_open":
                return True
            case _:
                return False
    
    def record_success(self):
        """Record successful call"""
        self.failure_count = 0
        self.success_count += 1
        self.total_calls += 1
        self.state = "closed"
    
    def record_failure(self):
        """Record failed call"""
        self.failure_count += 1
        self.total_calls += 1
        self.last_failure_time = time.time()
        
        if self.failure_count >= self.failure_threshold:
            self.state = "open"
    
    def get_health_score(self) -> float:
        """Calculate health score (0.0 to 1.0)"""
        if self.total_calls == 0:
            return 1.0
        return self.success_count / self.total_calls

@dataclass
class AssistantError:
    """Enhanced error response structure with context awareness"""
    error_type: ErrorType
    message: str
    details: Optional[str] = None
    fallback_response: Optional[str] = None
    retryable: bool = False
    user_facing: bool = True
    context: str = ""
    retry_after: Optional[float] = None
    recovery_suggestions: list[str] = field(default_factory=list)  # Python 3.13.4 syntax
    severity: str = "medium"  # low, medium, high, critical
    timestamp: float = field(default_factory=time.time)
    correlation_id: Optional[str] = None

class ErrorClassifier:
    """Error classification using exception types and patterns with Python 3.13.4 enhancements"""
    
    def __init__(self):
        self.error_patterns = self._initialize_error_patterns()
        self.dynamic_patterns: dict[str, list[str]] = defaultdict(list)  # Python 3.13.4 syntax
        self.error_history = deque(maxlen=1000)  # Track error patterns
        self.pattern_effectiveness: dict[str, float] = {}  # Track pattern accuracy
        
    def _initialize_error_patterns(self) -> list[ErrorPattern]:  # Python 3.13.4 syntax
        """Initialize comprehensive error patterns with Python 3.13.4 enhancements"""
        patterns = [
            # LLM Provider Errors
            ErrorPattern(
                exception_types={ConnectionError, TimeoutError, OSError, asyncio.TimeoutError},
                string_patterns={"connection", "timeout", "network", "unreachable", "dns", "socket"},
                error_type=ErrorType.CONNECTION_ERROR,
                retryable=True,
                priority=4,
                recovery_time=10.0
            ),
            
            # Rate Limiting - Enhanced patterns
            ErrorPattern(
                exception_types={Exception},
                string_patterns={
                    "rate limit", "429", "quota", "too many requests", "throttling",
                    "requests per minute", "api limit", "usage limit"
                },
                error_type=ErrorType.RATE_LIMIT,
                retryable=True,
                priority=5,
                recovery_time=60.0
            ),
            
            # Authentication Issues - Enhanced
            ErrorPattern(
                exception_types={PermissionError, ValueError, KeyError},
                string_patterns={
                    "unauthorized", "401", "forbidden", "403", "api key", 
                    "authentication", "invalid_api_key", "access denied", "token"
                },
                error_type=ErrorType.AUTHENTICATION_ERROR,
                retryable=False,
                priority=5,
                recovery_time=0.0
            ),
            
            # LangGraph Specific Errors - Enhanced
            ErrorPattern(
                exception_types={AttributeError, TypeError, RuntimeError},
                string_patterns={
                    "_asyncgeneratorcontextmanager", "get_next_version", "langgraph",
                    "graph", "node", "edge", "workflow", "state_graph"
                },
                error_type=ErrorType.CONTEXT_MANAGER_ERROR,
                retryable=False,
                priority=5,
                recovery_time=0.0
            ),
            
            # Checkpointer Errors - Enhanced
            ErrorPattern(
                exception_types={ConnectionError, OSError, ValueError, sqlite3.Error if 'sqlite3' in globals() else Exception},
                string_patterns={
                    "checkpointer", "checkpoint", "database", "conn", "sqlite", 
                    "postgres", "connection pool", "db", "sql"
                },
                error_type=ErrorType.CHECKPOINTER_ERROR,
                retryable=True,
                priority=4,
                recovery_time=30.0
            ),
            
            # State Management Errors - Enhanced
            ErrorPattern(
                exception_types={KeyError, TypeError, AttributeError, ValueError},
                string_patterns={
                    "state", "messages", "dict", "typeddict", "session_id",
                    "user_id", "current_agent", "message"
                },
                error_type=ErrorType.STATE_ERROR,
                retryable=True,
                priority=3,
                recovery_time=5.0
            ),
            
            # Model Overloaded - Enhanced
            ErrorPattern(
                exception_types={Exception},
                string_patterns={
                    "overloaded", "busy", "502", "503", "service unavailable", 
                    "capacity", "server error", "temporarily unavailable"
                },
                error_type=ErrorType.MODEL_OVERLOADED,
                retryable=True,
                priority=4,
                recovery_time=45.0
            ),
            
            # Configuration Errors - Enhanced
            ErrorPattern(
                exception_types={ImportError, ModuleNotFoundError, KeyError, FileNotFoundError},
                string_patterns={
                    "not found", "missing", "config", "import", "module",
                    "configuration", "settings", "yaml", "env"
                },
                error_type=ErrorType.CONFIGURATION_ERROR,
                retryable=False,
                priority=3,
                recovery_time=0.0
            ),
            
            # Tool Errors - Enhanced
            ErrorPattern(
                exception_types={FileNotFoundError, PermissionError, ValueError, OSError},
                string_patterns={
                    "tool", "function", "file", "permission", "directory",
                    "workspace", "read", "write", "execute"
                },
                error_type=ErrorType.TOOL_ERROR,
                retryable=True,
                priority=2,
                recovery_time=5.0
            ),
            
            # Network Errors - New
            ErrorPattern(
                exception_types={ConnectionError, OSError, TimeoutError},
                string_patterns={
                    "network", "internet", "connectivity", "host", "resolve",
                    "unreachable", "connection refused", "no route"
                },
                error_type=ErrorType.NETWORK_ERROR,
                retryable=True,
                priority=4,
                recovery_time=15.0
            ),
            
            # Resource Exhaustion - New
            ErrorPattern(
                exception_types={MemoryError, OSError},
                string_patterns={
                    "memory", "disk", "space", "resource", "exhausted",
                    "out of", "insufficient", "quota exceeded"
                },
                error_type=ErrorType.RESOURCE_EXHAUSTED,
                retryable=True,
                priority=3,
                recovery_time=60.0
            )
        ]
        
        # Sort by priority (higher first)
        return sorted(patterns, key=lambda p: p.priority, reverse=True)
    
    def classify_error(self, error: Exception, context: str = "") -> ErrorType:
        """Classify errors using multiple strategies with Python 3.13.4 enhancements"""
        error_str = str(error).lower()
        error_type = type(error)
        
        # Strategy 1: High-priority pattern matching
        for pattern in self.error_patterns:
            if pattern.matches(error, error_str):
                self._record_pattern_match(pattern.error_type, error, context, pattern)
                return pattern.error_type
        
        # Strategy 2: Context-based classification using match-case (Python 3.13.4)
        context_error_type = self._classify_by_context(error, context)
        if context_error_type:
            return context_error_type
        
        # Strategy 3: Dynamic pattern matching (learned patterns)
        dynamic_type = self._check_dynamic_patterns(error, context)
        if dynamic_type:
            return dynamic_type
        
        # Strategy 4: Fallback classification using match-case
        fallback_type = self._fallback_classification(error, error_str)
        self._record_pattern_match(fallback_type, error, context)
        return fallback_type
    
    def _classify_by_context(self, error: Exception, context: str) -> Optional[ErrorType]:
        """Classify errors based on context using match-case (Python 3.13.4)"""
        context_lower = context.lower()
        
        match context_lower:
            case ctx if "llm_generation" in ctx or "model" in ctx:
                return ErrorType.LLM_ERROR
            case ctx if "supervisor" in ctx or "routing" in ctx:
                return ErrorType.SUPERVISOR_ERROR
            case ctx if "checkpointer" in ctx or "checkpoint" in ctx:
                return ErrorType.CHECKPOINTER_ERROR
            case ctx if "tool_execution" in ctx or "tool" in ctx:
                return ErrorType.TOOL_ERROR
            case ctx if "state" in ctx or "message" in ctx:
                return ErrorType.STATE_ERROR
            case ctx if "validation" in ctx or "validate" in ctx:
                return ErrorType.VALIDATION_ERROR
            case ctx if "auth" in ctx or "permission" in ctx:
                return ErrorType.AUTHENTICATION_ERROR
            case ctx if "network" in ctx or "connection" in ctx:
                return ErrorType.NETWORK_ERROR
            case _:
                return None
    
    def _fallback_classification(self, error: Exception, error_str: str) -> ErrorType:
        """Fallback classification using match-case (Python 3.13.4)"""
        error_type = type(error)
        
        # Use isinstance checks instead of match-case for exception types
        if isinstance(error, (ConnectionError, OSError, asyncio.TimeoutError)):
            return ErrorType.CONNECTION_ERROR
        elif isinstance(error, PermissionError):
            return ErrorType.PERMISSION_ERROR
        elif isinstance(error, FileNotFoundError):
            return ErrorType.TOOL_ERROR
        elif isinstance(error, (KeyError, AttributeError)):
            return ErrorType.STATE_ERROR
        elif isinstance(error, (ValueError, TypeError)):
            return ErrorType.VALIDATION_ERROR
        elif isinstance(error, MemoryError):
            return ErrorType.RESOURCE_EXHAUSTED
        else:
            return ErrorType.SYSTEM_ERROR


    def _check_dynamic_patterns(self, error: Exception, context: str) -> Optional[ErrorType]:
        """Check dynamically learned patterns"""
        error_signature = f"{type(error).__name__}:{str(error)[:100]}"
        
        for error_type_str, signatures in self.dynamic_patterns.items():
            if any(sig in error_signature for sig in signatures):
                try:
                    return ErrorType(error_type_str)
                except ValueError:
                    continue
        
        return None
    
    def _record_pattern_match(
        self, 
        error_type: ErrorType, 
        error: Exception, 
        context: str, 
        pattern: Optional[ErrorPattern] = None
    ):
        """Record error pattern for learning and effectiveness tracking"""
        error_record = {
            "error_type": error_type.value,
            "exception_type": type(error).__name__,
            "error_message": str(error)[:200],
            "context": context,
            "timestamp": time.time(),
            "pattern_used": pattern.priority if pattern else 0
        }
        
        self.error_history.append(error_record)
        
        # Learn dynamic patterns
        error_signature = f"{type(error).__name__}:{str(error)[:50]}"
        if error_signature not in self.dynamic_patterns[error_type.value]:
            self.dynamic_patterns[error_type.value].append(error_signature)
            
        # Track pattern effectiveness
        if pattern:
            pattern_key = f"{pattern.error_type.value}:{pattern.priority}"
            self.pattern_effectiveness[pattern_key] = self.pattern_effectiveness.get(pattern_key, 0) + 1
    
    async def analyze_error_trends(self) -> dict[str, any]:  # Python 3.13.4 syntax
        """Analyze error trends asynchronously using TaskGroup"""
        try:
            async with TaskGroup() as tg:
                # Create analysis tasks
                distribution_task = tg.create_task(self._analyze_error_distribution())
                temporal_task = tg.create_task(self._analyze_temporal_patterns())
                context_task = tg.create_task(self._analyze_context_patterns())
            
            return {
                "distribution": distribution_task.result(),
                "temporal": temporal_task.result(),
                "context": context_task.result(),
                "total_errors": len(self.error_history),
                "pattern_effectiveness": dict(self.pattern_effectiveness)
            }
        except Exception as e:
            logger.error(f"Error trend analysis failed: {e}")
            return {"error": str(e)}
    
    async def _analyze_error_distribution(self) -> dict[str, any]:  # Python 3.13.4 syntax
        """Analyze error type distribution"""
        await asyncio.sleep(0)  # Yield control
        
        error_counts: dict[str, int] = defaultdict(int)  # Python 3.13.4 syntax
        for record in self.error_history:
            error_counts[record["error_type"]] += 1
        
        total = len(self.error_history)
        return {
            "counts": dict(error_counts),
            "percentages": {k: (v / total * 100) if total > 0 else 0 for k, v in error_counts.items()}
        }
    
    async def _analyze_temporal_patterns(self) -> dict[str, any]:  # Python 3.13.4 syntax
        """Analyze temporal error patterns"""
        await asyncio.sleep(0)  # Yield control
        
        current_time = time.time()
        recent_errors = [
            record for record in self.error_history
            if current_time - record["timestamp"] < 3600  # Last hour
        ]
        
        return {
            "recent_count": len(recent_errors),
            "error_rate_per_hour": len(recent_errors),
            "trending_errors": self._get_trending_errors(recent_errors)
        }
    
    async def _analyze_context_patterns(self) -> dict[str, any]:  # Python 3.13.4 syntax
        """Analyze context-based error patterns"""
        await asyncio.sleep(0)  # Yield control
        
        context_errors: dict[str, int] = defaultdict(int)  # Python 3.13.4 syntax
        for record in self.error_history:
            context = record.get("context", "unknown")
            context_errors[context] += 1
        
        return dict(context_errors)
    
    def _get_trending_errors(self, recent_errors: list[dict[str, any]]) -> list[str]:  # Python 3.13.4 syntax
        """Get trending error types"""
        error_counts: dict[str, int] = defaultdict(int)  # Python 3.13.4 syntax
        for error in recent_errors:
            error_counts[error["error_type"]] += 1
        
        # Sort by frequency and return top 3
        sorted_errors = sorted(error_counts.items(), key=lambda x: x[1], reverse=True)
        return [error_type for error_type, _ in sorted_errors[:3]]
    
    def get_error_statistics(self) -> dict[str, any]:  # Python 3.13.4 syntax
        """Get error classification statistics"""
        error_counts: dict[str, int] = defaultdict(int)  # Python 3.13.4 syntax
        recent_errors = []
        
        current_time = time.time()
        for record in self.error_history:
            error_counts[record["error_type"]] += 1
            if current_time - record["timestamp"] < 3600:  # Last hour
                recent_errors.append(record)
        
        return {
            "total_errors": len(self.error_history),
            "error_distribution": dict(error_counts),
            "recent_errors_count": len(recent_errors),
            "dynamic_patterns_count": sum(len(patterns) for patterns in self.dynamic_patterns.values()),
            "pattern_effectiveness": dict(self.pattern_effectiveness),
            "classification_accuracy": self._calculate_classification_accuracy()
        }
    
    def _calculate_classification_accuracy(self) -> float:
        """Calculate classification accuracy based on pattern effectiveness"""
        if not self.pattern_effectiveness:
            return 0.0
        
        total_classifications = sum(self.pattern_effectiveness.values())
        if total_classifications == 0:
            return 0.0
        
        # Simple accuracy metric based on successful pattern matches
        return min(1.0, total_classifications / len(self.error_history)) if self.error_history else 0.0

class CircuitBreakerManager:
    """Circuit breaker manager for external API calls with Python 3.13.4 enhancements"""
    
    def __init__(self):
        self.circuit_breakers: dict[str, CircuitBreakerState] = {}  # Python 3.13.4 syntax
        self.service_configs: dict[str, dict[str, any]] = {  # Python 3.13.4 syntax
            "anthropic": {"failure_threshold": 3, "recovery_timeout": 30.0},
            "openai": {"failure_threshold": 3, "recovery_timeout": 30.0},
            "tavily": {"failure_threshold": 5, "recovery_timeout": 60.0},
            "file_system": {"failure_threshold": 10, "recovery_timeout": 5.0}
        }
    
    def get_circuit_breaker(self, service_name: str) -> CircuitBreakerState:
        """Get or create circuit breaker for a service"""
        if service_name not in self.circuit_breakers:
            config = self.service_configs.get(service_name, {})
            self.circuit_breakers[service_name] = CircuitBreakerState(
                failure_threshold=config.get("failure_threshold", 5),
                recovery_timeout=config.get("recovery_timeout", 60.0),
                call_timeout=config.get("call_timeout", 30.0)
            )
        return self.circuit_breakers[service_name]
    
    async def call_with_circuit_breaker(
        self, 
        service_name: str, 
        func: Callable, 
        *args, 
        **kwargs
    ) -> any:  # Python 3.13.4 syntax
        """Execute function with circuit breaker protection"""
        circuit_breaker = self.get_circuit_breaker(service_name)
        
        if not circuit_breaker.should_allow_call():
            raise CircuitBreakerOpenException(f"Circuit breaker open for {service_name}")
        
        try:
            # Apply timeout with enhanced error handling
            result = await asyncio.wait_for(
                self._execute_function_safely(func, *args, **kwargs),
                timeout=circuit_breaker.call_timeout
            )
            circuit_breaker.record_success()
            return result
        except Exception as e:
            circuit_breaker.record_failure()
            logger.error(f"Circuit breaker call failed for {service_name}: {e}")
            raise
    
    async def _execute_function_safely(self, func: Callable, *args, **kwargs) -> any:  # Python 3.13.4 syntax
        """Safely execute function with proper async handling"""
        try:
            if inspect.iscoroutinefunction(func):
                return await func(*args, **kwargs)
            elif inspect.iscoroutine(func):
                return await func
            elif callable(func):
                # Run sync function in thread pool to avoid blocking
                loop = asyncio.get_event_loop()
                return await loop.run_in_executor(None, func, *args, **kwargs)
            else:
                return func
        except Exception as e:
            logger.error(f"Function execution failed: {e}")
            raise
    
    def get_circuit_status(self, service_name: str) -> dict[str, any]:  # Python 3.13.4 syntax
        """Get circuit breaker status"""
        if service_name not in self.circuit_breakers:
            return {"status": "not_initialized"}
        
        circuit = self.circuit_breakers[service_name]
        return {
            "service": service_name,
            "state": circuit.state,
            "failure_count": circuit.failure_count,
            "success_count": circuit.success_count,
            "total_calls": circuit.total_calls,
            "health_score": circuit.get_health_score(),
            "last_failure": circuit.last_failure_time,
            "time_since_failure": time.time() - circuit.last_failure_time if circuit.last_failure_time > 0 else None
        }
    
    async def health_check_all_services(self) -> dict[str, any]:  # Python 3.13.4 syntax
        """Perform health check on all services using TaskGroup"""
        try:
            async with TaskGroup() as tg:
                tasks = {
                    service_name: tg.create_task(self._health_check_service(service_name))
                    for service_name in self.circuit_breakers.keys()
                }
            
            return {
                service_name: task.result()
                for service_name, task in tasks.items()
            }
        except Exception as e:
            logger.error(f"Health check failed: {e}")
            return {"error": str(e)}
    
    async def _health_check_service(self, service_name: str) -> dict[str, any]:  # Python 3.13.4 syntax
        """Health check for individual service"""
        await asyncio.sleep(0)  # Yield control
        
        circuit = self.circuit_breakers.get(service_name)
        if not circuit:
            return {"status": "not_initialized"}
        
        return {
            "status": "healthy" if circuit.state == "closed" else circuit.state,
            "health_score": circuit.get_health_score(),
            "failure_count": circuit.failure_count,
            "success_rate": circuit.success_count / max(circuit.total_calls, 1)
        }

class CircuitBreakerOpenException(Exception):
    """Exception raised when circuit breaker is open"""
    pass

class ErrorHandler:
    """Error handling with intelligent classification and circuit breakers - Python 3.13.4 enhanced"""
    
    _classifier = ErrorClassifier()
    _circuit_breaker_manager = CircuitBreakerManager()
    
    @staticmethod
    async def handle_error(error: Exception, context: str = "") -> dict[str, any]:  # Python 3.13.4 syntax
        """Handle errors with intelligent classification and context awareness"""
        # Classify the error using sophisticated patterns
        error_type = ErrorHandler._classifier.classify_error(error, context)
        
        # Generate intelligent error response
        error_info = ErrorHandler._generate_error_info(error, error_type, context)
        
        # Log with appropriate level using match-case (Python 3.13.4)
        match error_info.severity:
            case "critical":
                log_level = logging.CRITICAL
            case "high":
                log_level = logging.ERROR
            case "medium":
                log_level = logging.WARNING
            case "low":
                log_level = logging.INFO
            case _:
                log_level = logging.WARNING
        
        logger.log(log_level, f"Error in {context}: {error_type.value} - {error}")
        
        # Build enhanced response
        response = {
            "response": error_info.fallback_response,
            "error": error_info.error_type.value,
            "error_message": error_info.message,
            "details": error_info.details,
            "retryable": error_info.retryable,
            "fallback_used": True,
            "context": context,
            "user_facing": error_info.user_facing,
            "severity": error_info.severity,
            "timestamp": error_info.timestamp
        }
        
        # Add retry information if applicable
        if error_info.retry_after:
            response["retry_after"] = error_info.retry_after
        
        if error_info.recovery_suggestions:
            response["recovery_suggestions"] = error_info.recovery_suggestions
        
        if error_info.correlation_id:
            response["correlation_id"] = error_info.correlation_id
        
        return response
    
    @staticmethod
    def _generate_error_info(error: Exception, error_type: ErrorType, context: str) -> AssistantError:
        """Generate comprehensive error information using match-case (Python 3.13.4)"""
        
        # Enhanced error configurations using match-case
        match error_type:
            case ErrorType.RATE_LIMIT:
                return AssistantError(
                    error_type=error_type,
                    message="Rate limit exceeded",
                    fallback_response="I'm experiencing high demand. Please try again in a moment.",
                    retryable=True,
                    retry_after=60.0,
                    severity="medium",
                    recovery_suggestions=["Wait a few minutes before retrying", "Try a simpler request"]
                )
            
            case ErrorType.CONNECTION_ERROR | ErrorType.NETWORK_ERROR:
                return AssistantError(
                    error_type=error_type,
                    message="Connection error",
                    fallback_response="I'm having trouble connecting to my services. Please try again.",
                    retryable=True,
                    retry_after=10.0,
                    severity="high",
                    recovery_suggestions=["Check your internet connection", "Try again in a few seconds"]
                )
            
            case ErrorType.AUTHENTICATION_ERROR:
                return AssistantError(
                    error_type=error_type,
                    message="Authentication error",
                    fallback_response="I'm experiencing an authentication issue. Please contact support.",
                    retryable=False,
                    user_facing=False,
                    severity="critical",
                    recovery_suggestions=["Check API key configuration", "Verify credentials"]
                )
            
            case ErrorType.MODEL_OVERLOADED:
                return AssistantError(
                    error_type=error_type,
                    message="Model overloaded",
                    fallback_response="The AI service is currently busy. Please try again shortly.",
                    retryable=True,
                    retry_after=30.0,
                    severity="medium",
                    recovery_suggestions=["Wait a moment and retry", "Try during off-peak hours"]
                )
            
            case ErrorType.CONTEXT_MANAGER_ERROR:
                return AssistantError(
                    error_type=error_type,
                    message="Async context manager error",
                    fallback_response="I'm experiencing a technical issue. Let me try a different approach.",
                    retryable=False,
                    severity="high",
                    recovery_suggestions=["Restart the assistant", "Check system configuration"]
                )
            
            case ErrorType.RESOURCE_EXHAUSTED:
                return AssistantError(
                    error_type=error_type,
                    message="Resource exhausted",
                    fallback_response="System resources are currently limited. Please try again later.",
                    retryable=True,
                    retry_after=120.0,
                    severity="high",
                    recovery_suggestions=["Free up system resources", "Try a simpler request"]
                )
            
            case _:
                return AssistantError(
                    error_type=error_type,
                    message="System error",
                    fallback_response=ErrorHandler.generate_fallback_response(error_type, context),
                    retryable=ErrorHandler.is_retryable_error(error),
                    severity="medium"
                )
    
    @staticmethod
    async def with_error_handling(
        func: Union[Callable, Awaitable], 
        *args, 
        context: str = "", 
        max_retries: int = 3,
        **kwargs
    ) -> any:  # Python 3.13.4 syntax
        """Execute function with comprehensive error handling and retry logic"""
        base_delay = 1.0
        correlation_id = f"err_{int(time.time())}_{hash(context) % 10000}"
        
        for attempt in range(max_retries + 1):
            try:
                # Handle different types of callables with enhanced logic
                if inspect.iscoroutine(func):
                    result = await func
                elif inspect.iscoroutinefunction(func):
                    result = await func(*args, **kwargs)
                elif callable(func):
                    result = func(*args, **kwargs)
                    if inspect.iscoroutine(result):
                        result = await result
                else:
                    result = func
                
                return result
                
            except Exception as e:
                error_type = ErrorHandler._classifier.classify_error(e, context)
                
                # Don't retry non-retryable errors
                if not ErrorHandler.is_retryable_error(e) or attempt == max_retries:
                    error_response = await ErrorHandler.handle_error(e, context)
                    error_response["correlation_id"] = correlation_id
                    return error_response
                
                # Calculate retry delay with exponential backoff and jitter
                retry_delay = base_delay * (2 ** attempt)
                jitter = retry_delay * 0.1 * (0.5 - 0.5 * (attempt / max_retries))
                total_delay = retry_delay + jitter
                
                logger.warning(
                    f"Attempt {attempt + 1}/{max_retries + 1} failed in {context}: {e}. "
                    f"Retrying in {total_delay:.2f}s (correlation_id: {correlation_id})"
                )
                await asyncio.sleep(total_delay)
        
        # This shouldn't be reached, but just in case
        error_response = await ErrorHandler.handle_error(
            Exception("Max retries exceeded"), context
        )
        error_response["correlation_id"] = correlation_id
        return error_response
    
    @staticmethod
    def generate_fallback_response(error_type: ErrorType, context: str = "") -> str:
        """Generate contextual fallback responses using match-case (Python 3.13.4)"""
        
        # Context-specific responses using match-case
        match context.lower():
            case ctx if "message_processing" in ctx:
                return "I'm ready to help with your next question."
            case ctx if "supervisor_processing" in ctx:
                return "Let me try routing your request differently."
            case ctx if "agent_execution" in ctx:
                return "I'll attempt to handle your request using a different approach."
            case ctx if "checkpointer_operation" in ctx:
                return "Your message was processed, but conversation history may not be saved."
            case ctx if "tool_execution" in ctx:
                return "I encountered an issue with a tool. Let me try another method."
            case ctx if "llm_generation" in ctx:
                return "I had trouble generating a response. Please try rephrasing your request."
        
        # Error type specific responses using match-case
        match error_type:
            case ErrorType.CONTEXT_MANAGER_ERROR:
                return "I'm experiencing a technical issue. Please try again."
            case ErrorType.CHECKPOINTER_ERROR:
                return "I'm having trouble with conversation persistence. Please continue."
            case ErrorType.STATE_ERROR:
                return "I encountered an issue with message handling. Please try rephrasing."
            case ErrorType.SUPERVISOR_ERROR:
                return "I'm experiencing a routing issue. Let me try a different approach."
            case ErrorType.TOOL_ERROR:
                return "I encountered an issue while using a tool. Let me try another method."
            case ErrorType.CONNECTION_ERROR | ErrorType.NETWORK_ERROR:
                return "I'm having trouble connecting to services. Please try again."
            case ErrorType.RATE_LIMIT:
                return "I'm experiencing high demand. Please try again in a moment."
            case ErrorType.TIMEOUT_ERROR:
                return "The request took too long. Please try again."
            case ErrorType.EMPTY_CONTENT:
                return "I detected an issue with the response. Please try rephrasing."
            case ErrorType.AUTHENTICATION_ERROR:
                return "I'm experiencing authentication issues. Please contact support."
            case ErrorType.MODEL_OVERLOADED:
                return "The AI service is currently busy. Please try again shortly."
            case ErrorType.RESOURCE_EXHAUSTED:
                return "System resources are currently limited. Please try again later."
            case _:
                return "I'm ready to help with your next question."
    
    @staticmethod
    def is_retryable_error(error: Exception) -> bool:
        """Determine if an error is retryable using intelligent classification"""
        error_type = ErrorHandler._classifier.classify_error(error)
        
        # Non-retryable error types using match-case (Python 3.13.4)
        match error_type:
            case (ErrorType.AUTHENTICATION_ERROR | 
                  ErrorType.CONFIGURATION_ERROR | 
                  ErrorType.CONTEXT_MANAGER_ERROR | 
                  ErrorType.DEPENDENCY_ERROR):
                return False
            case _:
                return True
    
    @staticmethod
    async def with_circuit_breaker(
        service_name: str,
        func: Callable,
        *args,
        context: str = "",
        **kwargs
    ) -> any:  # Python 3.13.4 syntax
        """Execute function with circuit breaker protection"""
        try:
            return await ErrorHandler._circuit_breaker_manager.call_with_circuit_breaker(
                service_name, func, *args, **kwargs
            )
        except Exception as e:
            return await ErrorHandler.handle_error(e, f"{context}_circuit_breaker")
    
    @staticmethod
    async def get_error_statistics() -> dict[str, any]:  # Python 3.13.4 syntax
        """Get comprehensive error statistics asynchronously"""
        try:
            async with TaskGroup() as tg:
                # Create analysis tasks
                classifier_task = tg.create_task(
                    ErrorHandler._classifier.analyze_error_trends()
                )
                circuit_task = tg.create_task(
                    ErrorHandler._circuit_breaker_manager.health_check_all_services()
                )
            
            classifier_stats = classifier_task.result()
            circuit_stats = circuit_task.result()
            
            return {
                "classification": classifier_stats,
                "circuit_breakers": circuit_stats,
                "patterns_learned": len(ErrorHandler._classifier.dynamic_patterns),
                "total_services": len(ErrorHandler._circuit_breaker_manager.circuit_breakers)
            }
        except Exception as e:
            logger.error(f"Error statistics collection failed: {e}")
            return {"error": str(e)}
    
    @staticmethod
    async def safe_execute_with_fallback(
        primary_func: Callable,
        fallback_func: Optional[Callable] = None,
        context: str = "",
        *args,
        **kwargs
    ) -> any:  # Python 3.13.4 syntax
        """Execute with intelligent fallback and circuit breaker protection"""
        try:
            return await ErrorHandler.with_error_handling(
                primary_func, *args, context=f"{context}_primary", **kwargs
            )
        except Exception as primary_error:
            logger.warning(f"Primary function failed in {context}: {primary_error}")
            
            if fallback_func:
                try:
                    return await ErrorHandler.with_error_handling(
                        fallback_func, *args, context=f"{context}_fallback", **kwargs
                    )
                except Exception as fallback_error:
                    logger.error(f"Fallback function also failed in {context}: {fallback_error}")
                    return await ErrorHandler.handle_error(fallback_error, f"{context}_fallback_failed")
            else:
                return await ErrorHandler.handle_error(primary_error, context)

# Export convenience functions
handle_error = ErrorHandler.handle_error
with_error_handling = ErrorHandler.with_error_handling
with_circuit_breaker = ErrorHandler.with_circuit_breaker

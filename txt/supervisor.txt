import logging
from typing import Dict, Any, Literal, Optional, List, Union, Self
from dataclasses import dataclass
from collections.abc import Sequence  # Python 3.13.4 preferred import

from langgraph.graph import StateGraph, START, END
from langgraph.prebuilt import ToolNode
from langchain_core.messages import AIMessage, HumanMessage, BaseMessage

from core.state import AssistantState
from core.error_handling import ErrorHandler

logger = logging.getLogger("supervisor")

@dataclass
class SupervisorConfig:
    """
    Configuration class for supervisor behavior.
    
    This allows for easy customization without modifying core logic.
    """
    max_replays: int = 5  # Prevent infinite agent-tool loops
    default_agent: str = "chat"  # Default fallback agent
    enable_routing_logs: bool = True  # Log routing decisions
    enable_human_in_loop: bool = False  # Enable human-in-the-loop for tools
    routing_keywords: Optional[dict[str, list[str]]] = None  # Python 3.13.4 syntax
    
    def __post_init__(self):
        """Initialize default routing keywords if not provided"""
        if self.routing_keywords is None:
            self.routing_keywords = {
                "coder": [
                    "code", "python", "function", "class", "def", "import", 
                    "script", "programming", "debug", "refactor", "algorithm",
                    "variable", "loop", "condition", "syntax", "error",
                    "compile", "execute", "method", "object", "inheritance"
                ],
                "web": [
                    "search", "web", "news", "internet", "google", "find", 
                    "lookup", "research", "browse", "website", "url",
                    "online", "information", "current", "latest", "recent"
                ]
            }

class SupervisorError(Exception):
    """Custom exception for supervisor-specific errors"""
    pass

class Supervisor:
    """
    A supervisor with intelligent routing and enhanced LangGraph 0.4.8 patterns
    """
    
    def __init__(self, config: Optional[SupervisorConfig] = None):
        self.config = config or SupervisorConfig()
        self.supervisor_graph = None
        self.agents: dict[str, Any] = {}  # Python 3.13.4 syntax
        self.tools: list[Any] = []  # Python 3.13.4 syntax
        self._routing_stats = {
            "total_routes": 0,
            "routes_by_agent": {},
            "routing_errors": 0
        }
        
    async def initialize(
        self, 
        agents: dict[str, Any],  # Python 3.13.4 syntax
        all_tools: list[Any],  # Python 3.13.4 syntax
        checkpointer=None
    ) -> None:
        """
        Initialize supervisor with agents and tools using modern LangGraph patterns.
        
        Args:
            agents: Dictionary of agent instances from AgentFactory
            all_tools: List of all tools from AgentFactory.get_all_tools()
            checkpointer: Optional checkpointer for state persistence
        """
        try:
            self.agents = agents
            self.tools = all_tools
            
            # Validate inputs
            self._validate_initialization_inputs(agents, all_tools)
            
            # Create the workflow graph with modern LangGraph 0.4.8 patterns
            workflow = StateGraph(AssistantState)

            # Use enhanced ToolNode with proper error handling
            tool_node = ToolNode(all_tools)
            workflow.add_node("call_tool", tool_node)
            
            # Add agent nodes with circuit breaker protection
            for agent_name, agent in agents.items():
                workflow.add_node(
                    agent_name, 
                    self._create_resilient_agent_node(agent, agent_name)
                )

            # Modern conditional routing with explicit fallback
            workflow.add_conditional_edges(
                START,
                self._enhanced_route_to_agent,
                {**{agent_name: agent_name for agent_name in agents.keys()}, 
                 "__end__": END}  # Explicit end condition
            )

            # Enhanced tool continuation with smart routing
            workflow.add_conditional_edges(
                "call_tool",
                self._smart_continuation_logic,
                {**{agent_name: agent_name for agent_name in agents.keys()},
                 "__end__": END}
            )

            # Wire up agent nodes to tool continuation
            for agent_name in agents.keys():
                workflow.add_conditional_edges(
                    agent_name, 
                    self._should_continue_to_tools,
                    {
                        "call_tool": "call_tool",
                        "__end__": END
                    }
                )
            
            # Compile with enhanced options for LangGraph 0.4.8
            compile_options = {
                "checkpointer": checkpointer,
                "debug": self.config.enable_routing_logs
            }
            
            # Add human-in-the-loop if enabled
            if self.config.enable_human_in_loop:
                compile_options["interrupt_before"] = ["call_tool"]
            
            self.supervisor_graph = workflow.compile(**compile_options)
            
            # Initialize routing statistics
            for agent_name in agents.keys():
                self._routing_stats["routes_by_agent"][agent_name] = 0
            
            if self.config.enable_routing_logs:
                logger.info(
                    f"✅ Enhanced supervisor initialized with {len(agents)} agents "
                    f"and {len(all_tools)} tools (LangGraph 0.4.8)"
                )
            
        except Exception as e:
            error_msg = f"Supervisor initialization failed: {str(e)}"
            logger.error(f"❌ {error_msg}")
            await ErrorHandler.handle_error(SupervisorError(error_msg), "supervisor_initialization")
            raise
    
    def _validate_initialization_inputs(self, agents: dict[str, Any], tools: list[Any]) -> None:
        """Validate initialization inputs for better error messages"""
        if not agents:
            raise SupervisorError("No agents provided for initialization")
        
        if not tools:
            logger.warning("⚠️ No tools provided - agents will have limited capabilities")
        
        # Validate default agent exists
        if self.config.default_agent not in agents:
            available_agents = list(agents.keys())
            if available_agents:
                self.config.default_agent = available_agents[0]
                logger.warning(
                    f"⚠️ Default agent '{self.config.default_agent}' not found. "
                    f"Using '{self.config.default_agent}' instead."
                )
            else:
                raise SupervisorError("No valid agents available")
    
    def _create_resilient_agent_node(self, agent: Any, agent_name: str):
        """
        Creates a graph-compatible node wrapper for agents with circuit breaker protection.
        """
        async def agent_node(state: AssistantState) -> dict[str, Any]:  # Python 3.13.4 syntax
            try:
                # Set current agent for tool routing
                state["current_agent"] = agent_name
                
                # Track routing statistics
                self._routing_stats["routes_by_agent"][agent_name] += 1
                self._routing_stats["total_routes"] += 1
                
                # Execute the agent with circuit breaker protection
                from core.circuit_breaker import global_circuit_breaker
                result = await global_circuit_breaker.call_with_circuit_breaker(
                    f"agent_{agent_name}",
                    agent.ainvoke,
                    state
                )
                
                # Ensure result is properly formatted
                if not isinstance(result, dict):
                    logger.warning(f"Agent {agent_name} returned non-dict result, wrapping")
                    result = {"messages": [AIMessage(content=str(result))]}
                
                return result
                
            except Exception as e:
                self._routing_stats["routing_errors"] += 1
                error_msg = f"Agent {agent_name} execution failed: {str(e)}"
                logger.error(f"❌ {error_msg}")
                
                # Return error state instead of crashing
                return {
                    "messages": [AIMessage(content="I encountered an issue. Please try rephrasing your request.")],
                    "current_agent": agent_name
                }
        
        return agent_node

    def _enhanced_route_to_agent(self, state: AssistantState) -> str:
        """
        Enhanced intelligent routing with configurable keywords and fallback logic.
        """
        try:
            messages = state.get("messages", [])
            
            # Find the most recent human message
            last_human_message = None
            for message in reversed(messages):
                if isinstance(message, HumanMessage):
                    last_human_message = message
                    break
            
            if not last_human_message:
                if self.config.enable_routing_logs:
                    logger.info(f"🎯 No human message found, routing to default: {self.config.default_agent}")
                return self.config.default_agent
            
            # Extract and analyze content
            content = str(getattr(last_human_message, 'content', '')).lower().strip()
            
            if not content:
                if self.config.enable_routing_logs:
                    logger.info(f"🎯 Empty content, routing to default: {self.config.default_agent}")
                return self.config.default_agent
            
            # Use configurable keyword matching with scoring
            agent_scores: dict[str, int] = {}  # Python 3.13.4 syntax
            
            for agent_name, keywords in self.config.routing_keywords.items():
                if agent_name in self.agents:  # Only route to available agents
                    score = sum(1 for keyword in keywords if keyword in content)
                    if score > 0:
                        agent_scores[agent_name] = score
            
            # Route to agent with highest score
            if agent_scores:
                best_agent = max(agent_scores.keys(), key=lambda x: agent_scores[x])
                if self.config.enable_routing_logs:
                    matched_keywords = [
                        kw for kw in self.config.routing_keywords[best_agent] 
                        if kw in content
                    ]
                    logger.info(
                        f"🎯 Routing to {best_agent} agent "
                        f"(score: {agent_scores[best_agent]}, matched: {', '.join(matched_keywords[:3])})"
                    )
                return best_agent
            
            # Default routing
            if self.config.enable_routing_logs:
                logger.info(f"🎯 No specific keywords matched, routing to default: {self.config.default_agent}")
            return self.config.default_agent
            
        except Exception as e:
            self._routing_stats["routing_errors"] += 1
            logger.error(f"❌ Routing error: {e}, using default agent: {self.config.default_agent}")
            return self.config.default_agent

    def _should_continue_to_tools(self, state: AssistantState) -> Literal["call_tool", "__end__"]:
        """Determine if the agent should call tools or end (Python 3.13.4 enhanced)"""
        messages = state.get("messages", [])
        last_message = messages[-1] if messages else None
        
        if isinstance(last_message, AIMessage) and hasattr(last_message, 'tool_calls'):
            if last_message.tool_calls:
                return "call_tool"
        return "__end__"

    def _smart_continuation_logic(self, state: AssistantState) -> str:
        """Smart logic for continuing after tool execution"""
        # Get the current agent from state, fallback to default
        current_agent = state.get("current_agent", self.config.default_agent)
        
        # Ensure the agent still exists
        if current_agent in self.agents:
            return current_agent
        
        # Fallback to default agent
        return self.config.default_agent
    
    async def process(self, state: AssistantState, config_dict: dict[str, Any]) -> AssistantState:
        """
        Process a request through the supervisor graph with enhanced error handling.
        """
        try:
            if not self.supervisor_graph:
                raise SupervisorError("Supervisor not initialized. Call initialize() first.")
            
            # Validate state
            if not isinstance(state, dict):
                raise SupervisorError(f"Invalid state type: {type(state)}. Expected dict.")
            
            # Process through the graph with timeout protection
            import asyncio
            result = await asyncio.wait_for(
                self.supervisor_graph.ainvoke(state, config_dict),
                timeout=300.0  # 5 minute timeout
            )
            
            # Validate result
            if not isinstance(result, dict):
                logger.warning("Graph returned non-dict result, wrapping")
                result = {
                    "messages": [AIMessage(content=str(result))],
                    "session_id": state.get("session_id", ""),
                    "user_id": state.get("user_id", ""),
                    "current_agent": state.get("current_agent", self.config.default_agent)
                }
            
            return result
            
        except Exception as e:
            logger.error(f"❌ Supervisor processing error: {e}")
            raise
    
    def get_routing_statistics(self) -> dict[str, Any]:  # Python 3.13.4 syntax
        """Get routing statistics for monitoring and debugging"""
        return {
            "config": {
                "default_agent": self.config.default_agent,
                "max_replays": self.config.max_replays,
                "routing_logs_enabled": self.config.enable_routing_logs,
                "human_in_loop_enabled": self.config.enable_human_in_loop
            },
            "stats": dict(self._routing_stats),
            "agents_available": list(self.agents.keys()),
            "tools_count": len(self.tools),
            "graph_initialized": self.supervisor_graph is not None
        }
    
    def update_routing_keywords(self, agent_name: str, keywords: list[str]) -> None:  # Python 3.13.4 syntax
        """
        Update routing keywords for a specific agent.
        
        This allows dynamic configuration of routing behavior.
        """
        if agent_name not in self.agents:
            logger.warning(f"⚠️ Agent '{agent_name}' not found, cannot update keywords")
            return
        
        self.config.routing_keywords[agent_name] = keywords
        logger.info(f"✅ Updated routing keywords for {agent_name}: {len(keywords)} keywords")
    
    def get_configuration(self) -> SupervisorConfig:
        """Get current supervisor configuration"""
        return self.config
    
    def set_configuration(self, new_config: SupervisorConfig) -> None:
        """
        Update supervisor configuration.
        
        Note: This requires reinitialization to take full effect.
        """
        self.config = new_config
        logger.info("✅ Supervisor configuration updated. Reinitialize for full effect.")

    async def stream_events(self, state: AssistantState, config_dict: dict[str, Any]):
        """
        Stream events from the supervisor graph (LangGraph 0.4.8 feature).
        """
        if not self.supervisor_graph:
            raise SupervisorError("Supervisor not initialized. Call initialize() first.")
        
        async for event in self.supervisor_graph.astream_events(state, config_dict, version="v1"):
            yield event

    def visualize_graph(self) -> str:
        """
        Generate a visual representation of the supervisor graph.
        """
        if not self.supervisor_graph:
            return "Graph not initialized"
        
        try:
            # Use LangGraph's built-in visualization if available
            return self.supervisor_graph.get_graph().draw_mermaid()
        except AttributeError:
            # Fallback to text representation
            return f"Supervisor Graph: {len(self.agents)} agents, {len(self.tools)} tools"
